<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TEETHER:Gnawing at ethereum to Automatically Exploit Smart Contracts]]></title>
    <url>%2F2018%2F12%2F19%2Fteether%2F</url>
    <content type="text"><![CDATA[摘要针对智能合约实现自动化漏洞识别和注入。为有漏洞的合约生成通用定义，在字节码的基础上使用TEETHER实现注入。 介绍这个工具主要用来实现自动化漏洞注入，假设攻击者无任何特权。对合约漏洞进行定义，合约中价值的转移只在少数情况下发生。为此定义了四种标准：可以用来创建常规交易的(CALL)，用来结束合约的(SELFDESTRUCT)，两个可以引起代码注入的(CALLCODE, DELEGATECALL)我们提出了一种方法来找到一个合约中的漏洞执行路径，并且使用符号执行来自动化生成一个注入。方法如下: 我们在合约的控制流图中寻找关键路径，然后确定参数可以被攻击者控制的关键指令。一旦确定了一条路径，我们利用符号执行将这条路径转化成一系列的约束条件。使用约束条件求解器我们就可以推断攻击者必须执行哪些事务来触发漏洞。智能合约的特定执行环境使这个任务并不简单。值得注意的是，我们展示了如何符号化地处理哈希值，这些哈希值在智能合约中被广泛使用。为了评估我们方法的实用性，我们对区块链上38757个合约进行了大规模分析。TEETHER发现了815个合约可以被自动化注入，不需要人工交互和确定，并且不需要合约的源代码。因为代码共享，这使1731个账户处于危险之中。更进一步，示例表明，许多这些潜在的漏洞是由于Solidity的设计机制和对EVM执行模式的误解导致的。主要贡献:1.在低级的EVM指令上，提出了一个漏洞合约的广泛定义。2.基于智能合约字节码提出了一个端到端的自动化注入工具。最后我们还处理了一些EVM的特定挑战，比如说符号化地处理哈希值的新方法。3.使用这个工具对智能合约进行了大规模的分析。 背景在这部分介绍智能合约，以太坊虚拟机和智能合约的执行模式。 交易系统用户在转账和调用合约的时候发起交易，矿工处理交易并且使用共识协议确认新出的块。矿工挖块会获得处理费，为了防止拒绝服务攻击和鼓励矿工出块。区块链上的每个节点都可以验证目前的系统状态。 智能合约智能合约是与特定代码片段相关的以太坊账户，每个智能合约都有私有存储，]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JarvisOJ_软件破解(1)]]></title>
    <url>%2F2018%2F12%2F18%2Fjarvis-wp4%2F</url>
    <content type="text"><![CDATA[下载文件下载文件后解压，得到一个可执行文件，用PEiD分析，发现软件没有加壳，而且是32位的可执行文件。 用Ollydbg分析将文件在od中打开，查看引用的所有字符串：发现了图中”你赢了”字样的字符串，猜想判断语句应该在其附近。转到该位置:在其周围发现一系列的判断和跳转语句，猜想应该与字符串判断相关:在上面”输入口令”字样处下断点: 动态调试运行下断点后进行动态调试运行，发现程序在输入字符串后确实停留在断点位置，step over：根据调试信息和汇编语句可以判断出程序的执行逻辑:图中红色大方框中是循环判断字符串的汇编代码，其逻辑是: 取EAX与ECX相加后得到地址中的值赋予DL 将DL与EAX地址中的字符串亦或(EAX中的字符串就是输入的字符串)EAX与ECX的地址相加为0x00CD77F8，其中具体值如红色长方框中所示。在异或完成后将结果与46171C1B, 3020FDF4, 7E8E0CB7, 78, DE进行比较，只有值全部相等时才认为正确。编写程序解码注意最后比较的数字中有高低位的区别123456s1 = [0x28, 0x57, 0x64, 0x6B, 0x93, 0x8F, 0x65, 0x51, 0xE3, 0x53, 0xE4, 0x4E, 0x1A, 0xFF]s2 = [0x1B, 0x1C, 0x17, 0x46, 0xF4, 0xFD, 0x20, 0x30, 0xB7, 0x0C, 0x8E, 0x7E, 0x78, 0xDE]flag = ''for i in range(len(s1)): flag = flag + chr(s2[i] ^ s1[i])print flag 运行后得到的flag为：3Ks-grEaT_j0b!]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JarvisOJ_stheasy]]></title>
    <url>%2F2018%2F12%2F17%2Fjarvis-wp3%2F</url>
    <content type="text"><![CDATA[使用file指令查看文件属性1234$file ctf2ctf2: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.18, BuildID[sha1]=ae99a50022c1d9d3bf96c045151d1edcdab9af94, stripped 在linux下尝试运行123$ ./ctf2Input flag:jdijifFlag is wrong. 在IDA32下打开main函数的伪代码:红色方框中是进行匹配的函数名称sub_8048530()函数伪代码:所求的flag与数组byte_8049B15和字符串byte_8049AE0有关，它们具体的值如下：红色方框为字符串，蓝色方框为数组的值 可以根据下列代码解出flag123456789num = [0x48, 0x5D, 0x8D, 0x24, 0x84, 0x27, 0x99, 0x9F, 0x54, 0x18, \ 0x1E, 0x69, 0x7E, 0x33, 0x15, 0x72, 0x8D, 0x33, 0x24, 0x63, 0x21, \ 0x54, 0x0C, 0x78, 0x78, 0x78, 0x78, 0x78, 0x1B, 0x0]s = 'ak2j9Gh&#125;AgfY4ds-a6QW1#k5ER_T[cvLbV7nOm3ZeX&#123;CMt8SZo]U'f = ''print len(s)for i in range(29): f = f + s[num[i] / 3 - 2]print f 运行出来flag的值为:kctf{YoU_hAVe-GOt-fLg_233333}]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JarvisOJ_FindKey]]></title>
    <url>%2F2018%2F12%2F17%2Fjarvis-wp2%2F</url>
    <content type="text"><![CDATA[下载文件使用file指令查看文件类型:12$file findkeyfindkey.pyo: python 2.7 byte-compiled 发现文件是python2的字节码文件 使用python运行findkey字节码123$ python findkey.pyoInput your Key:hhhWrong Key!! 使用uncompyle6工具对python字节码反汇编安装：python -m pip install uncompyle6使用: compyle6 findkey获得的反汇编代码:12345678910111213141516171819202122232425# uncompyle6 version 3.2.4# Python bytecode 2.7 (62211)# Decompiled from: Python 2.7.15rc1 (default, Nov 12 2018, 14:31:15) # [GCC 7.3.0]# Embedded file name: findkey# Compiled at: 2016-04-30 02:54:18import syslookup = [196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2, 245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224, 69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73, 148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22, 55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186, 0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113, 79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185, 183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9, 136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208, 207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120, 195, 45, 4, 142, 139]pwda = [188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42]pwdb = [53, 222, 230, 35, 67, 248, 226, 216, 17, 209, 32, 2, 181, 200, 171, 60, 108]flag = raw_input('Input your Key:').strip()if len(flag) != 17: print 'Wrong Key!!' sys.exit(1)flag = flag[::-1]for i in range(0, len(flag)): if ord(flag[i]) + pwda[i] &amp; 255 != lookup[i + pwdb[i]]: print 'Wrong Key!!' sys.exit(1)print 'Congratulations!!'# okay decompiling findkey.pyoFile '-o' doesn't exist. SkippedFile 'test.py' doesn't exist. Skipped# # Successfully decompiled file 使用下列代码获取key123456789import syslookup = [196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2, 245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224, 69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73, 148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22, 55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186, 0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113, 79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185, 183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9, 136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208, 207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120, 195, 45, 4, 142, 139]pwda = [188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42]pwdb = [53, 222, 230, 35, 67, 248, 226, 216, 17, 209, 32, 2, 181, 200, 171, 60, 108]flag = &apos;&apos;for i in range(0, len(pwda)): tmp = lookup[i + pwdb[i]] - pwda[i] &amp; 255 flag = flag + chr(tmp)print flag[::-1] python中s[start: end: step]，所以flag[::-1]表示从字符串结尾到字符串开头逆序]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JarvisOJ_CrackMe]]></title>
    <url>%2F2018%2F12%2F17%2Fjarvis-wp1%2F</url>
    <content type="text"><![CDATA[题目下载后得到exe可执行文件，执行界面如下：FLAG就是注册码，说明需要得到与输入字符串相匹配的正确注册码 使用PEiD工具分析exe文件是否加壳，运行结果如下：说明可执行文件没有被加壳，编程语言是C# 使用.NET Reflector对可执行文件进行分析：注册码使用Base64编码后的结果为:UENURntFYTV5X0RvX05ldF9DcjRjazNyfQ==使用Base64解码后结果为:PCTF{Ea5y_Do_Net_Cr4ck3r}]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PEiD的使用]]></title>
    <url>%2F2018%2F12%2F17%2Fpeid%2F</url>
    <content type="text"><![CDATA[PEiD是一个经典的查壳程序,其插件数量远超百种,使它具备了各种功能,例如通用脱壳和针对性脱壳.虽然已经停止更新,但是特征,签名检测等技术没有失效,你只需要给予其新的特征识别库即可用于新壳的检测. 什么时候需要使用PEiD 快速鉴定一个程序是否正常? 它的入口点是什么? 用什么工具开发的 是否被加了已知壳? 查看它的反汇编代码 PE头结构 脱简易的壳使用图中红色方框中的内容表示文件用什么软件编写的，或者用什么软件加壳。这里表示是用C#编写的。如果是未知软件，点击红色方框可以显示有没有加壳，具体信息需要点击弹出框中的绿色框中的按钮。]]></content>
      <categories>
        <category>逆向_工具</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向笔记]]></title>
    <url>%2F2018%2F12%2F13%2Fre-notes%2F</url>
    <content type="text"><![CDATA[学习网站CTF WikiJarvis OJSUCTF 常规逆向流程1.使用strings/file/binwalk/IDA等静态分析工具收集信息，并根据这些静态信息进行google/github搜索2.研究程序的保护方法，如代码混淆，保护壳及反调试等技术，并设法破除或绕过保护3.反汇编目标软件，快速定位到关键代码进行分析4.结合动态调试，验证自己的初期猜想，在分析的过程中理清程序功能5.针对程序功能，写出对应脚本，求解出 flag CTF逆向中通常出现的加密算法Base64将 3 字节的数据，先后放入一个 24 位的缓冲区中，先来的字节占高位。数据不足 3 字节的话，于缓冲器中剩下的比特用 0 补足。每次取出 6 比特，按照其值选择ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/中的字符作为编码后的输出，直到全部输入数据转换完成。通常而言 Base64 的识别特征为索引表，当我们能找到ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/这样索引表，再经过简单的分析基本就能判定是 Base64 编码。有些题目 base64 的索引表是会变的，一些变种的 base64 主要 就是修改了这个索引表。 Tea(Tiny Encryption Algorithm微型加密算法)是一个简单的分组加密算法，使用Feistel结构进行加密。每次加密64位，密钥长度为128位，推荐迭代次数为64.在 Tea 算法中其最主要的识别特征就是 拥有一个 image number ：0x9e3779b9，有些编程人员为了避免在程序中直接出现”mov 变量，0x9e3779b”，以免被破解者直接搜索0x9e3779b这个常数得知使用TEA算法，所以有时会使用”sub 变量，0x61C88647“代替”mov 变量，0x9e3779b”，0x61C88647=－(0x9e3779b)。最初的Tea算法已经被破解，增加了许多变种形式，比如说XTea,XxTea… RC4流加密算法MD5鲜明标识：1234h0 = 0x67452301;h1 = 0xefcdab89;h2 = 0x98badcfe;h3 = 0x10325476; 虚拟机指令Unicorn引擎Unicorn 是一个轻量级, 多平台, 多架构的 CPU 模拟器框架. 我们可以将其应用于这些情景: 比如我们单纯只是需要模拟代码的执行而非需要一个真的 CPU 去完成那些操作, 又或者想要更安全地分析恶意代码, 检测病毒特征, 或者想要在逆向过程中验证某些代码的含义.一个简单的例子如下：1234567891011121314151617181920212223242526272829303132333435363738from __future__ import print_functionfrom unicorn import *from unicorn.x86_const import *# code to be emulatedX86_CODE32 = b"\x41\x4a" # INC ecx; DEC edx# memory address where emulation startsADDRESS = 0x1000000print("Emulate i386 code")try: # Initialize emulator in X86-32bit mode mu = Uc(UC_ARCH_X86, UC_MODE_32) # map 2MB memory for this emulation mu.mem_map(ADDRESS, 2 * 1024 * 1024) # write machine code to be emulated to memory mu.mem_write(ADDRESS, X86_CODE32) # initialize machine registers mu.reg_write(UC_X86_REG_ECX, 0x1234) mu.reg_write(UC_X86_REG_EDX, 0x7890) # emulate code in infinite time &amp; unlimited instructions mu.emu_start(ADDRESS, ADDRESS + len(X86_CODE32)) # now print out some registers print("Emulation done. Below is the CPU context") r_ecx = mu.reg_read(UC_X86_REG_ECX) r_edx = mu.reg_read(UC_X86_REG_EDX) print("&gt;&gt;&gt; ECX = 0x%x" %r_ecx) print("&gt;&gt;&gt; EDX = 0x%x" %r_edx)except UcError as e: print("ERROR: %s" % e) 更多示例代码]]></content>
      <categories>
        <category>逆向_学习笔记</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn学习笔记]]></title>
    <url>%2F2018%2F12%2F13%2Fpwn-note%2F</url>
    <content type="text"><![CDATA[学习网站CTF WikiJarvis OJSUCTFpwnable.twpwnable.kr 查看二进制文件是32位系统还是64位系统1file filename 查看文件用了哪些保护机制12gdb filename(gdb) checksec 各种保护机制的作用Cannary: 栈溢出保护，用来缓解缓冲区溢出攻击，当启用栈保护以后，函数开始执行时会先在栈里面插入cookie信息，当函数真正的返回的时候会验证cookie信息是否合法，如果不合法就停止运行程序Fortify: 也是为了防止缓冲区溢出攻击NX(Windows平台称其为DEP): 不可执行，将数据所在的内页标记为不可执行，如果程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不会执行恶意指令。PIE(ASLR): ASLR:地址随机化。PIE:Position Independent Executables位置独立的可执行区域。 二进制文件中的函数查找1readelf -a libc-2.19.so | grep &quot;system&quot; 二进制文件中的字符串查找1strings -a -t x libc-2.19.so | grep &quot;/bin/sh&quot; pwndbg工具在docker中的使用docker run -it \—rm \-h ${ctf_name} \—name ${ctf_name} \-v $(pwd)/${ctf_name}:/ctf/work \-p 23946:23946 \—cap-add=SYS_PTRACE \skysider/pwndocker]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu:16.04 docker安装]]></title>
    <url>%2F2018%2F12%2F13%2Fdocker-install%2F</url>
    <content type="text"><![CDATA[卸载旧的版本123$ sudo apt-get remove docker \ docker-engine \ docker.io 使用APT安装添加使用 HTTPS 传输的软件包以及 CA 证书1234567$ sudo apt-get update$ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common 为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥1$ curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 向 source.list 中添加 Docker 软件源1234$ sudo add-apt-repository \ &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \ $(lsb_release -cs) \ stable&quot; 安装Docker CE1234$ sudo add-apt-repository \ &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \ $(lsb_release -cs) \ stable&quot; 建立Docker用户组建立Docker组1$ sudo groupadd docker 当前用户加入Docker组1sudo usermod -aG docker $USER 启动Docker CE12$ sudo systemctl enable docker$ sudo systemctl start docker 进行如下测试123456$ docker run hello-worldUnable to find image &apos;hello-world:latest&apos; locallylatest: Pulling from library/hello-worldca4f61b1923c: Pull complete... 镜像加速配置国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如: Docker 官方提供的中国 registry mirror https://registry.docker-cn.com 七牛云加速器 https://reg-mirror.qiniu.com/ 修改/etc/docker/daemon.json文件sudo gedit /etc/docker/daemon.json添加以下内容：12345&#123; &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot; ]&#125; 重新启动服务12$ sudo systemctl daemon-reload$ sudo systemctl restart docker Docker: Got permission denied问题描述12345678910$ docker versionClient: Version: 18.06.1-ce API version: 1.38 Go version: go1.10.4 Git commit: e68fc7a Built: Mon Oct 1 14:25:31 2018 OS/Arch: linux/amd64 Experimental: falseGot permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.38/version: dial unix /var/run/docker.sock: connect: permission denied 解决方案1$ sudo chmod 666 /var/run/docker.sock Docker: error with docker stop/kill问题描述123$sudo docker kill webserverError response from daemon: Cannot kill container: webserver: Cannot kill container 0e06fdc024071aeb655a04fc12baa51cac09c2b1ab2139d810b27e1cdf4f967e: unknown error after kill: docker-runc did not terminate sucessfully: container_linux.go:393: signaling init process caused &quot;permission denied&quot;: unknown 解决方案Check status: sudo aa-statusShutdown and prevent it from restarting: sudo systemctl disable apparmor.service --nowUnload AppArmor profiles: sudo service apparmor teardownCheck status: sudo aa-statusAppArmor和SELinux都用于Liunx的强制访问控制(MAC)]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZEUS:Analyzing Safety of Smart Contracts]]></title>
    <url>%2F2018%2F12%2F11%2Fzeus%2F</url>
    <content type="text"><![CDATA[摘要一个智能合约无论占有多少资金在部署完成以后很难再修补漏洞。最近一个漏洞导致近五千万美元的加密货币损失。我们设计了验证智能合约正确性和公平性的框架—ZEUS。正确性指符合程序安全规则，公平性指符合高级商业逻辑。ZEUS利用抽象解释和符号执行方法进行检查，并且使用了约束角条款来快速验证合约的安全。我们基于以太坊和超级账本平台构建了ZEUS，并且使用它评估了超过22.4K的合约。我们的评估表明，超过94.6%的合约(持有加密货币价值超过5亿)是有漏洞的。ZEUS有零漏报率和低误报率，并且与现有技术相比研究分析时间上有一个数量级的改进。Constrained Horn Clause(CHC) verfication约束角条款验证 CHC是用来表示程序行为的中间语言，可以用来解释命令式、功能式、并发式的语言，也可以用来解释状态机、交易系统、马尔科夫链等计算模型。成功案例：Windows设备驱动验证现有工具：Z3、QARMC(CEGAR—Counter Example Guided Abstraction Refinement)、TRACER、VeriMAP(specialisation) 介绍区块链是巩固比特币等加密货币的设计模式。它使用共识算法来保证互不信任的节点在无可行第三方的参与下进行可验证交易。它的应用使得智能合约可以使用程序性的编码规则反映任意多方交易。去年区块链投资超过14亿美元，而且自主应用的增加趋势使得智能合约正迅速成为实施金融工具的首选手段(比如说:货币、衍生品、钱包等)还有去中性化的赌博应用。共识机制使得智能合约忠实执行，参与方的特权有：1.验证智能合约的正确性,ie:句法实现满足最佳编程实践;2.验证智能合约的公平性,ie:程序满足高层次的商业交易逻辑.虽然人工审计智能合约的正确性在某种程度上是可能的，但是它容易出错。但另一方面，自动正式审计需要特定的工具和逻辑。而且智能合约不像其他分布式系统代码一样，无论它持有多少金额，它都不可篡改并且难以修补，这使得问题进一步加剧。举例来说，TheDAO的投资者损失了将近5千万美元的加密货币，因为程序漏洞允许攻击者不断虹吸资金。在这篇文章中，我们跟踪了智能合约的正式验证问题，在部署之前验证其正确性和公平性至关重要。1234567891011while (Balance &gt; (depositors[index].Amount * 115/100) &amp;&amp; index &lt; Total_Investors) &#123; if(depositors[index].Amount!=0) &#123; payment = depositors[index].Amount * 115/100; depositors[index].EtherAddress.send(payment); Balance -= payment; Total_Paid_Out += payment; depositors[index].Amount = 0; //remove investor &#125; break;&#125; 上述智能合约向任何投资者提供15%的利润，但是它同时存在正确性和公平性的问题。第一，第六行的算术计算可能发生溢出，这是一个正确性的漏洞；第二，变量index在循环中从来都没有增加过，所以回报仅仅给了一个投资者；最后，break语句在付款给第一个投资者(智能合约部署者)后执行直接终止循环，所以该合约并不偿还任意其他的投资者，后两个漏洞导致了公平性的问题。大多数智能合约领域的现有技术旨在处理安全性和设计时的隐私问题，很少研究智能合约的缺陷.Oyente在字节码层次上使用符号执行来检测漏洞，但他既不兼容也不健全。就像我们观察和与Oyente开发人员沟通过的那样，即使在一些微不足道的合约中也会出现很多误报。因为仅依靠字节码很难恢复作者意图(因为缺少上下文信息:包含类型、不同的函数调用重用相同的字节码等)很多公平性和正确性的问题，包含整数上溢和下溢还有其他的，都被Oyente忽略了。更近一步，它保守地处理循环，导致低估了循环行为，所以会忽略代码1中的两个公平性的漏洞。Bhargavan提出了一个框架F*来正式验证Solidity编写的智能合约，它忽视了一些结构，比如说循环。考虑到我们分析的22493个合约，将近93%的智能合约包含循环。所以他们的工具只能在一小部分的公开合约上使用，他们的结果对这一点也进行了论证，在396个合约中他们只能分析其中46个。但是使用F*可以推理大多数正确性和公平性的属性，它的作者建议对这种推理使用手工证明，虽然还不清楚这种情况什么时候会发生。相比之下，我们建立了一个大规模的自动验证。Why3是一个正式验证Solidity合约可靠性的实验工具，它正处于开发中并且仅支持少部分的语法。更进一步，Solidity到Why3的翻译没有经过测试也不可信。我们提出了ZEUS的设计和实现—使用抽象解释和符号执行来自动化正式验证智能合约的实践框架。ZEUS使用高级语言编写的智能合约作为输入，它利用用户帮助来生成一个XACML模板风格的正确性和公平性的标准。它将这些合约和特定的准则翻译成一个低级的中间表示，比如说LLVM字节码，对执行语义进行编码以正确推断合约行为。然后在中间代码上进行静态分析以确定必须声明验证的谓词。最后ZEUS将修改后的IR放入验证引擎中，验证引擎使用CHCs来快速验证智能合约的安全性。ZEUS利用三个主要的观察指标来保证稳定性和可靠性。第一，虽然区块链的执行类似于基于任务语义的并发系统，一个交易只能从一个智能合约公开函数调用开始。这种属性大大减少了验证大多数属性的状态空间探索。而且，交易之间的数据依赖比如说在持续变量之间的读写依赖要求分析O(n^2)对事务交错。第二，智能合约是控制流和数据流驱使的，所以使用抽象解释和符号模型对智能合约建模允许ZEUS可靠的推测程序行为。抽象解释计算数据域上的循环和函数摘要，然后在模型检查阶段使用这些循环和函数摘要，减少模型检查阶段操作的状态空间。最后，CHCs提供一个合适的机制来表示验证条件，它可以被SMT求解器有效地释放。SMT solver(Satisfiability modulo theories)可满足模理论求解器 SAT—布尔可满足性求解器。用于求解等式系统，不同的是，SMT接受不同格式的等式系统，而SAT对输入格式是有要求的，必须是CNF范式的布尔等式。用于形式化验证 XACML(eXtensible Access Control Markup Language可扩展访问控制标记语言) 是一个定义用于访问控制的体系结构和语言，语言由响应、回复和Policy组成，客户端发送一个请求给服务器，询问一个特定的动作是否可以被允许执行。服务器使用已有的Policy对请求进行评估，然后进行回复。这些Policy实现了组织的访问控制请求。 ZEUS基于LLVM字节码做验证也收益良多，不仅仅是因为ZEUS可以使用一个产业化的工具链做分析，它还允许ZEUS在标准化的LLVM字节码上插入任意验证器，使用LLVM字节码还帮助ZEUS验证不同区块链平台的智能合约，包含以太坊、超级账本，使用不同高级语言编写，比如说C#,Go和JAVA。注意，大多数高级语言到LLVM字节码的翻译器已经可以获得。我们使用LLVM丰富的API集合来编写第一个Solidity到LLVM字节码的翻译器，为了验证忠实地实现了大多数Solidity语法的执行语义。更进一步，使用LLVM允许ZEUS将翻译实现和验证分离。这篇文章做出来以下贡献：(1) 我们对新的或者早已出现但是没有经过研究的事件在智能合约的上下文中进行分类，并且证明他们可以潜在地导致资金流失。(2) 我们提出了一种形式化的Solidity执行语义抽象，结合抽象解释和符号模型检查来验证智能合约。(3) 我们设计并实现了ZEUS，一个符号模型检查框架来验证正确性和合法性，我们设计了第一个Solidity到LLVM字节码的翻译器，并且提供一个程序分析模型来自动化插入给定Policy规范的验证条件。我们还提供了抽象Policy来正确建模Solidity的执行语义保证可靠性。更近一步，我们建立了一个交互式谓词提取工具便于智能合约中多方交互。(4) 我们进行了第一个大规模Solidity智能合约源码分析，我们分析了22493个智能合约(1524个比较特殊)表明大概有94.6%的合约有一个甚至多个安全漏洞。但是我们并没有研究这些漏洞的实际可利用性。而且我们选择了几个有代表性的合约并且应用了一些智能合约特定的公平性准则。(5) 智能合约有零漏报率，并且在我们的数据集上优于Oyente，误报率低，在分析时间上有一个数量级的改进。(6) 通过用它分析超级账本的智能合约，我们展示了ZEUS的普遍可用性。我们还通过使用SMACK进行验证，演示了将ZEUS应用于选择的验证器的易用性(SMACK用于将源语言细节与验证器实现解耦) 背景区块链是进行多方可验证交易的分布式账本，可以防止篡改和抵赖。除了交易之外，每一个区块还包含状态元数据(创建时的时间戳、交易的Merkle哈希、上一个块的哈希值、智能合约代码和数据)，挖矿是对每个块执行分布式计算评审的过程，用于相互不信任的环境中实现共识无限制区块链：公有链有限制区块链：联盟链 激励智能合约的正确性和安全性问题 A. 正确性问题(1) 重入攻击是因为call语句导致合约控制流转换产生的漏洞12345678910111213contract Wallet&#123; mapping(address =&gt; uint) private userBalances; function withdrawBalance() &#123; uint amountToWithdraw = userBalances[msg.sender]; if (amountToWithdraw &gt; 0) &#123; msg.sender.call(userBalances[msg.sender]); userBalances[msg.sender] = 0; &#125; &#125; ...&#125; 12345678contract AttackerContract&#123; function () &#123; Wallet wallet; wallet.withdrawBalance(); &#125;&#125; (2) 未经检查的sendsend操作如果失败合约并不终止，而是返回false，有些合约不检查send执行的状态直接进行下一步操作导致合约出现漏洞。12345if(gameHasEnded &amp;&amp; !prizePaidOut)&#123; winner.send(1000); // send a prize to the winner prizePaidOut = True;&#125; (3) send操作失败(4) 整数上下溢出(5) 交易状态依赖tx.origin指的是交易的最初发起者，但交易的最初发起者不一定是智能合约函数的直接调用者。1234567contract UserWallet &#123; function transfer(address dest, uint amount) &#123; if (tx.origin != owner) &#123; throw; &#125; dest.send(amount); &#125;&#125; 1234567contract AttackWallet &#123; function() &#123; UserWallet w = UserWallet(userWalletAddr); w.transfer(thiefStorageAddr, msg.sender.balance); &#125;&#125; 可以使用社会工程学的方式诱导UserWallet的部署者调用AttackWallet合约，此时tx.origin指的就是UserWallet而不是msg.sender B. 公平性的问题语义正确的合约并不一定遵守实际逻辑(1) 逻辑抽象使用selfdestruct时不对调用者的身份进行检测。解决问题会给予奖励，但是如果合约中的金额不足以支持奖励支付可能会导致合约得到了难题的解答但是并没有给予解决问题的人奖励。(2) 逻辑不正确相似的变量名或者函数名导致的混淆构造函数与合约名称完全不同并且为public类型，导致外部也可以调用这个构造函数(3) 逻辑正确但是不公平指的是合约代码不符合实际的商业逻辑需求。论文中举的是一个进行拍卖的合约，正常拍卖活动中应该限制拍卖方进行竞价，合约中并没有排除这种拍卖方竞价的情况。 C. 矿工的影响(1) 区块状态依赖。时间戳、挖矿难度、gaslimit这些变量可能被用来生成随机数，但是这些变量可以被区块头部影响，而矿工又可以影响区块头部内容(加大成功的概率)(2) 交易顺序依赖。矿工可以决定一个区块中的交易顺序。并发系统长期以来都在处理由于事务排序而导致的数据竞争问题。虽然Solidity不支持并发性，但由于其自身的重新排序标准，矿工可以影响事务的结果。由于这种对事务排序的依赖是一个通用的区块链特性，所以我们认为它是一个限制，而不是缺陷。 ZEUSZEUS的组成：1.policy构建器;2.源代码翻译器;3.验证器。ZEUS使用智能合约源码和使用特定语言编写的policy(用来验证合约)作为输入，它在智能合约的代码之上执行静态分析，并将Policy谓词作为assert语句插入正确的程序点。ZEUS使用翻译器将带有Policy assert语句的智能合约翻译成LLVM字节码。最后ZEUS调用它的验证器来确定assert违规，这表示Policy违规(就是调用验证器来确定assert语句是否会执行，如果执行了就表示违规) A. 标准化Solidity语法设计了一个抽象语言来捕获Solidity程序的相关结构。一个程序由一系列的合约声明组成。除了声明和初始化合约的持久私有存储之外，每个合约可以抽象地看作一个或多个方法定义的序列，这些方法定义由关键字global表示。一个合约可以用一个ID唯一的表示，ID属于一组标识符。调用一个合约的public函数可以看成一笔交易。为了简化，方法只有一个输入变量类型T和一个单一的全局变量，所以T可以是集合或者结构体。Solidity中的函数调用可以分为三种:internal, external和call。internal和external是通过goto语句实现的或者是内联的。call调用使用post。合约的主体被标记位S。相反，可以使用跨合约的参数调用post语句。因此，参数l是post的一部分。我们语言的语义抽象具体的值和操作。因此，对我们来说，T或特定表达式语言e的枚举仍然是未指定的。语言的具体细节不重要，我们可以假定为任何传统命令式语言定义的线性算术表达式。havoc语句为变量l赋一个不确定的值。assert语句在符号编码中引入了对谓词真值的检查。assume语句阻塞，直到提供的表达式变为true并在合约中的给定控件位置指定数据状态为止。虽然关于Solidity和我们的抽象语言在语义上的等价性的正式讨论是可取的，并且可以通过定义从Solidity结构到抽象语言结构的抽象函数来建立，但是为了空间的利益，我们省略了它。相反，我们用抽象语言直观地推理各种Solidity结构及其等效模型。class,library和interfaces这些结构在我们的抽象语言中可以被认为是全局变量和函数的集合，编译器在翻译C/C++代码到LLVM字节码的过程中也将他们视作相似的。struct,mapping,array,bytes都是全局的。像sha256这种可以影响同一个合约状态的方法被认为是external方法。像send,transfer和call这种对地址进行操作的语句是通过post语句进行建模的。像selfdestruct这样的特殊结构是用我们的抽象语言本地建模的。Solidity中所有的控制语句和函数修饰符都可以被解糖成if-then-else和goto的形式。像assert,require和throw这种出错处理也可以用if-then和throw表示。注意，在我们的语言中assert和assume是用来做验证的，assert语句与在Solidity中的语法不同。其他的编译指令，比如说constant和storage也被解糖了，而不是用我们的抽象语言明确建模的。语法糖语法糖实际上是一种便捷写法。比如说input.map(item =&gt; item + 1)表示的是：123input.map(function (item) &#123; return item + 1;&#125;); 语法糖的作用就是让写代码更加简单和容易理解。(相反的操作就是加盐)之所以叫「语法」糖，不只是因为加糖后的代码功能与加糖前保持一致，更重要的是，糖在不改变其所在位置的语法结构的前提下，实现了运行时等价。可以简单理解为，加糖后的代码编译后跟加糖前一模一样。语言语义区块状态被定义为：$&lt;&lt;\Gamma, \sigma&gt;, BC&gt;$, $&lt;\Gamma, \sigma&gt;$是B正在挖掘的块，BC是已经提交的块列表，$\Gamma$指已经完成但是还没有提交的交易集合。Val是表达式在求值后可以取的值集合。$\sigma$是全局状态，$\sigma:Id-&gt;g$指合约标识到全局变量的映射。$\sigma$是指矿工按照特定顺序执行$\Gamma$后的状态。最后，交易确定后矿工将B加入自己的区块中。交易由一系列的帧(用$\gamma$表示)组成。每一个帧被进一步定义为$f := &lt;l, id, M, pc, v&gt;$,l是方法的局部变量，M是合约(标识符为id)的代码，pc是程序计数器，v := 是用来存储输入输出的辅助存储器。$\gamma$的顶帧是正在执行的帧，与目前正在进行的交易有关，它不是持久区块链状态的一部分。一个空的帧可以被标记为$\epsilon$，标识符c被定义为$c := &lt;\gamma, \sigma&gt;$用来捕获交易状态，$\leadsto$表示小步骤操作语义.下表列出了管理配置更改的相关语法规则，其余顺序语句的规则是标准的。符号$\to$说明一个交易与全局状态和区块链状态相关。符号$\gets$表示对一个lvar(局部变量)赋值。Table 1 B.标准化规则语言假设PVars是一组程序变量，Func是一组智能合约中的函数名称，Expr是一组条件表达式(特定的无量词一阶逻辑(FOL)公式)。Policy规范必须使用这些语法符号，以避免在验证期间产生歧义ZEUS利用用户的帮助建立了一个XACML风格的Policy模板&lt;Sub, Obj, Op, Cond, Res&gt;。$Sub \in PVar$ 是一组需要被跟踪的变量，$Obj \in PVar$是一组与主体交互的变量，Op是一组侧影响调用，用于捕获主体和对象之间交互的效果。Op还指定了一个触发器属性，即“pre”或“post”，指示谓词应该在指定操作之前还是之后保存，换句话说，Op := &lt;f, trig&gt;这里$f \in Func, trig \in (pre, post)$。条件$Cond \in Expr$是一组控制导致交互操作的谓词集。最后,$Res \in {T, F}$表明主体和操作之间被谓词控制的交互是被允许的还是被禁止的.Policy到assertion之间的转换我们的抽象语言包含assertion来定义智能合约中的状态可达特性。ZEUS利用policy来提取(a)需要assert的谓词(i.e. Cond)(b)在程序源代码中插入assert语句的正确控制位置.Cond在我们的抽象语言中是一个表达式，使用这个表达式谓词并将其包装在assert(exp)下，将在我们的抽象语言中创建一条语句，Res指示条件是以正常形式出现，还是以否定形式出现在assert语句中.Op表示谓词(如条件所示)必须满足trig.trig和Sub,Obj准确地判断操作的哪些调用应该以条件为前缀或后缀。换句话说，我们精确地知道了抽象程序P中必须assert Cond的位置更正式的说，$f: Sub \times Obj \times Op \to Loc$，Loc是一组程序位置。使用污点分析来确定Sub和Obj结合使用的地方，通过只选择调用指定操作的那些控件位置，可以进一步细化此集合。最后的位置就是需要assert(Cond)的位置。 C.可靠性将源代码翻译成带有assert语句的抽象语言，并最后转换成LLVM字节码的过程是可靠的。1.Solidity翻译成我们的抽象语言不会影响语法表现，2.保守的替换assert语句不会影响方法的可靠性，2.把policy的确认问题转换成了一个状态可达问题。4.在Solidity程序的上下文中定义了一个可达状态。5.我们证明，通过确保程序的过近似版本具有状态可达性，我们不会遗漏任何程序行为。最后，我们证明从过近似的Solidity程序到LLVM字节码的翻译是完全一对一的翻译，我们的整体稳健性模块的决策过程被保留。(1) 从Solidity到抽象语言从Solidity到我们抽象语言的翻译过程保留了源语言的语义行为，虽然我们需要一个关于实体的语义等价性和我们的抽象语言的形式化论证，但是为了空间的利益，我们忽略了它。(2) 污点分析对可靠性的影响污点分析确定插入谓词语句的位置，可能会在多个位置插入谓词语句，这种插入可能会引入误报率但是不会漏报，所以我们的方法是可靠的。(3) policy验证的语义实现policy是无量词的一阶逻辑公式，policy的验证可以被简化成状态可达问题，i.e.是否存在从开始策略就不成立的可达状态。policy $\phi$ hold on 程序P,当$N \models \phi$,N是程序P做一个状态转换关系有限自动机的正式表示。assert(exp)在抽象语言中与高级语言中的assert语句有不同的语法含义。(4) 程序中assertion的安全意味着policy的确认定理1:源程序的安全性等价于翻译后程序的安全性证明:assert语句的语义规则表明不会对除了程序计算器以外的任何数据状态造成改变。assert仅作为标记与底层验证器相关，以生成验证条件。翻译前后的程序行为相同，所以assertion的安全性也相同。(5) Over-approximation的安全性assert语句的加入不影响安全性(6) 方法的安全性抽象语言到LLVM字节码也是安全的(soundness) D.通过CHCs执行符号检查ZEUS使用CHCsA. Gurfinkel et al., “The SeaHorn Verification Framework,” in CAV’15来验证翻译成LLVM字节码后程序的安全性.CHC表示的优点使其能够与各种基于smt的求解器和现成的模型检查器进行交互 E.端到端的示例下图展示了一个各种端到端翻译的示例，合约向msg.sender发送msg.value的金额，然后在bal[msg.sender]中减去msg.value。policy检查send调用必须满足msg.sender的余额大于msg.value。ZEUS从policy中提取条件，将其转换成assert语句放入Solidity中，然后将其转换成抽象语言，最后将程序翻译成LLVM字节码。 实现在Solidty的C++编译器solc的基础上实现policy builder和Solidity到LLVM的翻译器。使用Seahorn做符号模型检查的后端来验证policy。我们没有从头构建验证器，而是确定在LLVM字节码上使用CHCs时Seahorn为我们提供了一个现成的使用生成验证条件的实现。但是ZEUS不与Seahorn耦合，还可以使用任何工作在LLVM字节码上的验证器，比如说SMACK和DIVINE. A. Policy BuilderZEUS从AST节点上提取标识信息。从AST树的函数调用节点上提取操作，而谓词是从表示二进制操作的节点中的条件中提取的。ZEUS在合约代码上进行污点分析，然后进行API提取，ZEUS还会捕获控制流条件和路径谓词，污点分析的输出是一组元组，由源、对象、接收器及其对应的路径谓词组成。然后ZEUS列出了所有可用的污点集合，即，全局变量和环境变量，用户从中选择要跟踪的subject。然后，它过滤来自污点分析的结果，该污点分析将搜索空间减少到包含用户选择的至少一个subject的元组.ZEUS然后提示用户选择对象，然后进一步删除元组列表.然后显示至少涉及一个或多个subject或object的潜在调用的列表。在进一步选择之后，ZEUS列出了从源到接收器所遇到的可用谓词。用户可以使用布尔运算符组合这些谓词(或指定自己的谓词)，以在策略中形成条件，并指示是否将它们作为前置条件或后置条件检查。最后，用户在结果标记中指出规范是否确定了违反或接受的行为。 B. Solidity到LLVM字节码的翻译器为了便于实现，它读取策略规范并重写位代码(而不是Solidity源代码)，以便按照规范中的触发器属性为谓词注入断言条件。大多数Solidity的语句和表达式都有与C/C++相同的语义。使用LLVM的API来翻译AST。(1) 执行顺序由于在没有强制执行全局调用顺序的情况下，可以任意地对契约的公共函数进行许多并行调用，因此建模这些无限多的执行顺序是不可能的。我们注意到，对于7个类中的6个类(除了依赖于事务顺序的类)，错误检测是事务内部的。换句话说，验证者需要对一个调用链中的bug进行推理。事务的顺序不会影响事务中的bug检测。对事务顺序依赖关系的检测涉及到跨一对事务检测对敏感全局变量的写操作和后续读操作。对函数对进行推理就足够了，因为事务顺序依赖的最小实例必须在至少两个函数调用之间表现出来。剩余函数的排序对于检测bug来说是无关紧要的。因此，对于具有n个公开可用函数的契约，ZEUS必须对O(n^2)可能的排序进行推理。ZEUS产生了一套main函数，作为验证的切入点。具体来说，主函数是一个在调用公开定义的函数之前拥有所有全局状态的工具。对于事务顺序依赖，ZEUS拥有全局状态，并从一个主要功能中调用所有公共功能的成对排列。此外，ZEUS在调用call家族的任何成员时拥有整个全局状态。(2) 路径遍历在Solidity中，全局变量在执行过程中保持状态。在一个静态分析执行中建模和推理所有这些状态是不切实际的。因此，ZEUS将契约中所有全局变量(包括块和事务状态变量)的值抽象为与数据类型对应的整个数据域。例如，uint256类型的全局变量被建模为具有整型域，并且可以接受0到INT_MAX之间的任何值。对于任何具体定义的起始值，ZEUS都会自动使用它们来探索整个数据域。保持初始值不变并不会导致所有可能的执行，因为该值可能在后续的契约执行中增加，并可能在将来导致潜在的可使用性。因此，单个静态执行就足以分析所有可能的控制路径。==blabla翻译高级语法的一些细节和ZEUS的缺陷== C.Handling Correctness Bugs(1)重入漏洞创建一个完全相同的函数，但是其中加入assert(false)语句，主要是为了验证在进行实际的转账操作之前是否对变量进行了操作。(2)send状态没有检查禁止在send操作失败的时候对全局变量进行修改。即在每一个全局变量修改的地方插入assert()语句。(3)send失败不允许在send失败的时候立刻调用throw语句。(4)整数溢出操作使用LLVM工具链中的整数检查器。]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文,智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下LLVM开发环境的配置]]></title>
    <url>%2F2018%2F10%2F08%2Fllvm%2F</url>
    <content type="text"><![CDATA[安装clang和cmakesudo apt-get install clang cmake 安装llvmsudo apt-get install llvm使用这种方法我默认安装上的llvm版本为3.8.0，安装后的文件目录为/usr/share/llvm-3.8 修改LLVMConfig.cmake文件set(LLVM_CMAKE_DIR &quot;${LLVM_INSTALL_PREFIX}/share/llvm/cmake&quot;)改为set(LLVM_CMAKE_DIR &quot;${LLVM_INSTALL_PREFIX}/share/llvm-3.8/cmake&quot;) 修改LLVMExports-relwithdebinfo.cmake文件由于权限问题不能直接打开修改，在命令行中写入:sudo gedit LLVMExports-relwithdebinfo.cmake对文件进行如下修改:123#Commands may need to know the format version. set(CMAKE_IMPORT_FILE_VERSION 1)set(_IMPORT_PREFIX &quot;/usr/lib/llvm-3.8&quot;) 注释与Polly相关的库引用1234567891011121314151617181920212223242526272829# Import target "PollyISL" for configuration "RelWithDebInfo" # set_property(TARGET PollyISL APPEND PROPERTY IMPORTED_CONFIGURATIONS RELWITHDEBINFO) # set_target_properties(PollyISL PROPERTIES # IMPORTED_LINK_INTERFACE_LANGUAGES_RELWITHDEBINFO "C" # IMPORTED_LOCATION_RELWITHDEBINFO "$&#123;_IMPORT_PREFIX&#125;/lib/libPollyISL.a" # ) # # list(APPEND _IMPORT_CHECK_TARGETS PollyISL ) # list(APPEND _IMPORT_CHECK_FILES_FOR_PollyISL "$&#123;_IMPORT_PREFIX&#125;/lib/libPollyISL.a" ) # # # Import target "Polly" for configuration "RelWithDebInfo" # set_property(TARGET Polly APPEND PROPERTY IMPORTED_CONFIGURATIONS RELWITHDEBINFO) # set_target_properties(Polly PROPERTIES # IMPORTED_LINK_INTERFACE_LANGUAGES_RELWITHDEBINFO "CXX" # IMPORTED_LOCATION_RELWITHDEBINFO "$&#123;_IMPORT_PREFIX&#125;/lib/libPolly.a" # ) # # list(APPEND _IMPORT_CHECK_TARGETS Polly ) # list(APPEND _IMPORT_CHECK_FILES_FOR_Polly "$&#123;_IMPORT_PREFIX&#125;/lib/libPolly.a" ) # # # Import target "LLVMPolly" for configuration "RelWithDebInfo" # set_property(TARGET LLVMPolly APPEND PROPERTY IMPORTED_CONFIGURATIONS RELWITHDEBINFO) # set_target_properties(LLVMPolly PROPERTIES # IMPORTED_LOCATION_RELWITHDEBINFO "$&#123;_IMPORT_PREFIX&#125;/lib/LLVMPolly.so" # IMPORTED_NO_SONAME_RELWITHDEBINFO "TRUE" # ) # # list(APPEND _IMPORT_CHECK_TARGETS LLVMPolly ) # list(APPEND _IMPORT_CHECK_FILES_FOR_LLVMPolly "$&#123;_IMPORT_PREFIX&#125;/lib/LLVMPolly.so" ) 使用LLVM进行开发新建文件夹: HowToUseJIT目录结构如下:12345HowToUseJIT -- src + -- HowToUseJIT.cpp -- CMakeLists.txt -- build 在HowToUseJIT文件夹下进行如下操作:123cd buildcmake ..make HowToUseJIT.cpp和CMakeLists.txt文件可以自己根据LLVM提供的API自行开发，也可以使用下面所给的例子：HowToUseJIT.cpp1234567891011121314151617181920212223242526272829303132333435363738#include "llvm/IR/LLVMContext.h"#include "llvm/IR/Function.h"#include "llvm/IR/BasicBlock.h"#include "llvm/ADT/ArrayRef.h"#include "llvm/IR/Module.h"#include "llvm/IR/IRBuilder.h"#include &lt;vector&gt;#include &lt;string&gt; int main()&#123; llvm::LLVMContext &amp; context = llvm::getGlobalContext(); llvm::Module *module = new llvm::Module("asdf", context); llvm::IRBuilder&lt;&gt; builder(context); llvm::FunctionType *funcType = llvm::FunctionType::get(builder.getVoidTy(), false); llvm::Function *mainFunc = llvm::Function::Create(funcType, llvm::Function::ExternalLinkage, "main", module); llvm::BasicBlock *entry = llvm::BasicBlock::Create(context, "entrypoint", mainFunc); builder.SetInsertPoint(entry); llvm::Value *helloWorld = builder.CreateGlobalStringPtr("hello world!\n"); std::vector&lt;llvm::Type *&gt; putsArgs; putsArgs.push_back(builder.getInt8Ty()-&gt;getPointerTo()); llvm::ArrayRef&lt;llvm::Type*&gt; argsRef(putsArgs); llvm::FunctionType *putsType = llvm::FunctionType::get(builder.getInt32Ty(), argsRef, false); //llvm::Constant *putsFunc = module-&gt;getOrInsertFunction("puts", putsType); llvm::Function *putsFunc = llvm::Function::Create(putsType, llvm::Function::ExternalLinkage, "puts", module); llvm::BasicBlock *putsentry = llvm::BasicBlock::Create(context, "entrypoint", putsFunc); builder.SetInsertPoint(putsentry); builder.CreateCall(putsFunc, helloWorld); builder.CreateRetVoid(); module-&gt;dump();&#125; CMakeLists.txt123456789101112131415161718192021222324252627282930313233343536373839404142cmake_minimum_required(VERSION 2.8)project(llvm_test)set(LLVM_TARGETS_TO_BUILD X86)set(LLVM_BUILD_RUNTIME OFF)set(LLVM_BUILD_TOOLS OFF)find_package(LLVM REQUIRED CONFIG)message(STATUS "Found LLVM $&#123;LLVM_INCLUDE_DIRS&#125;")message(STATUS "Using LLVMConfig.cmake in: $&#123;LLVM_DIR&#125;")SET (CMAKE_CXX_COMPILER_ENV_VAR "clang++")SET (CMAKE_CXX_FLAGS "-std=c++11")SET (CMAKE_CXX_FLAGS_DEBUG "-g")SET (CMAKE_CXX_FLAGS_MINSIZEREL "-Os -DNDEBUG")SET (CMAKE_CXX_FLAGS_RELEASE "-O4 -DNDEBUG")SET (CMAKE_CXX_FLAGS_RELWITHDEBINFO "-O2 -g")SET(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)add_definitions($&#123;LLVM_DEFINITIONS&#125;)file(GLOB_RECURSE source_files "$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp")add_executable(llvm_test $&#123;source_files&#125;)install(TARGETS llvm_test RUNTIME DESTINATION bin)# Find the libraries that correspond to the LLVM components# that we wish to usellvm_map_components_to_libnames(llvm_libs Core ExecutionEngine Interpreter MC Support nativecodegen)# Link against LLVM librariestarget_link_libraries(llvm_test $&#123;llvm_libs&#125;) 如果编译通过说明LLVM开发环境搭建成功，如果报一些库文件缺失的错误有可能是因为默认LLVM文件夹的文件名为llvm而安装LLVM后自带的文件名为llvm-3.8可以根据报错内容对/usr/share/llvm-3.8或usr/lib/llvm-3.8的文件名进行修改]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
      </tags>
  </entry>
</search>
