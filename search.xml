<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用算法(二)]]></title>
    <url>%2F2019%2F12%2F02%2Fscript2%2F</url>
    <content type="text"><![CDATA[Base64因为很多时候题目会对Base64魔改，所以具体实现一下被魔改的话方便直接拿来用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Base64: def __init__(self): self.value = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" self.left = 0 # 多出来的位数为0 def encode(self, origin_bytes): base64_str = "" remain = len(origin_bytes) % 3 if remain: self.left = 3 - remain else: self.left = 0 # self.left = 3 - len(origin_bytes) % 3 if self.left: origin_bytes = origin_bytes + '\0' * self.left for i in range(0, len(origin_bytes), 3): a1 = ord(origin_bytes[i]) a2 = ord(origin_bytes[i + 1]) a3 = ord(origin_bytes[i + 2]) b1 = a1 &gt;&gt; 2 b2 = ((a1 &amp; 3) &lt;&lt; 4) + (a2 &gt;&gt; 4) b3 = ((a2 &amp; 15) &lt;&lt; 2) + (a3 &gt;&gt; 6) b4 = a3 &amp; (pow(2, 6) - 1) base64_str = base64_str + self.value[(b1)%64] + self.value[(b2)%64] + self.value[(b3)%64] + self.value[(b4)%64] if self.left: base64_str = base64_str[0: -self.left] + '='*self.left return base64_str def decode(self, base64_str): origin_bytes = '' base64_bytes_list = ['&#123;:0&gt;6&#125;'.format(str(bin((self.value.index(s))%64)).replace('0b', '')) for s in base64_str if s != '='] base64_bytes = "".join(base64_bytes_list) remain = len(base64_bytes_list) % 4 nums = len(base64_bytes_list) // 4 for i in range(nums): a1 = int(base64_bytes[24 * i: (24 * i + 8)], 2) a2 = int(base64_bytes[(24 * i + 8): (24 * i + 16)], 2) a3 = int(base64_bytes[(24 * i + 16): (24 * i + 24)], 2) origin_bytes = origin_bytes + chr(a1) + chr(a2) + chr(a3) if remain: remain_part = base64_bytes[24 * nums :] tmp_unit = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)] for i in tmp_unit: origin_bytes = origin_bytes + chr(i) # hexbytes = "" # for d in origin_bytes: # hexbytes = hexbytes + (hex(ord(d))[2:]).zfill(2) 16进制的形式表示 return origin_bytesbase64 = Base64()ori = "hello, world"enc = base64.encode(ori)dec = base64.decode(enc)print(enc)print(dec) SM4安洵杯有一道SM4加密算法的题，又是hook又是base64魔改又是SM4的…没了解过SM4所以是直接逆的，出来的flag里面提示说是SM4，了解记录一下。 加密算法SM4算法结构图:(注意最后反序输出)SM4的密钥扩展过程:系统参数FK取值:1FK0=(A2B1BAC6) FK1=(56AA3350) FK2=(677D9197) FK3=(B27022DC) 固定参数CK取值: 解密算法SM4算法的解密变换与加密变换结构相同，不同的仅是轮密钥的使用顺序，解密时使用轮密钥序(rk31,rk30,···,rk0) 实现在github上找了一个脚本：https://github.com/yang3yen/pysm4安装: python setup.py install加解密:12345678910from pysm4 import encrypt, decryptplain = "hello,sm4"clear_num = int(plain.encode('hex'), 16)key = "where_are_u_now!"mk = int(key.encode('hex'), 16)cipher_num = encrypt(clear_num, mk)cipher = hex(cipher_num)[2:].replace('L', '')print cipherclear_num_dec = decrypt(cipher_num, mk)print (hex(cipher_num_dec)[2:].replace('L', '')).decode('hex')]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用算法(一)]]></title>
    <url>%2F2019%2F11%2F22%2Fscript%2F</url>
    <content type="text"><![CDATA[Crypto算法库ubuntu安装：apt-get install python3-crypto123456常见对称密码在 Crypto.Cipher 库下，主要有：DES 3DES AES RC4 Salsa20非对称密码在 Crypto.PublicKey 库下，主要有：RSA ECC DSA哈希密码在 Crypto.Hash 库下，常用的有：MD5 SHA-1 SHA-128 SHA-256随机数在 Crypto.Random 库下实用小工具在 Crypto.Util 库下数字签名在 Crypto.Signature 库下 DES用crypto库，DES密钥长度是64位，对64位明文组进行加密12345678910111213141516from Crypto.Cipher import DESimport base64key = bytes('test_key'.ljust(8,' '),encoding='utf8')des = DES.new(key,DES.MODE_ECB)# encryptplain_text = bytes('this_is_a_plain'.ljust(16,' '),encoding='utf8')text_enc = des.encrypt(plain_text)text_enc_b64 = base64.b64encode(text_enc)print(text_enc_b64.decode(encoding='utf8'))# decryptmsg_enc = base64.b64decode(text_enc_b64)msg = des.decrypt(msg_enc)print(msg.decode(encoding='utf8')) key和明文是需要填充到指定位数的，可以使用ljust或者zfill之类的填充，也可以用Util中的pad()函数填充 AESAES根据密钥长度分为AES-128, AES-192, AES-256，以上三种消息长度都是128位也就是16字节12345678910111213141516171819from Crypto.Cipher import AESimport base64import mathkey = bytes('this_is_a_key'.ljust(16,' '),encoding='utf8') # 这里密钥长度可以是16，24，32aes = AES.new(key,AES.MODE_ECB)# encryptm = 'this_is_a_plainbsdvjhbdbhjbfhdbvdshkbhdfbjdjfbv'length_m = len(m)plain_text = bytes(m.ljust(16 * math.ceil(length_m*1.0 / 16),' '),encoding='utf8')text_enc = aes.encrypt(plain_text)text_enc_b64 = base64.b64encode(text_enc)print(text_enc_b64.decode(encoding='utf8'))# decryptmsg_enc = base64.b64decode(text_enc_b64)msg = aes.decrypt(msg_enc)print(msg.decode(encoding='utf8')) RSA生成公私钥12345678910111213from Crypto.PublicKey import RSArsa = RSA.generate(2048) # 返回的是密钥对象public_pem = rsa.publickey().exportKey('PEM') # 生成公钥字节流private_pem = rsa.exportKey('PEM') # 生成私钥字节流f = open('public.pem','wb')f.write(public_pem) # 将字节流写入文件f.close()f = open('private.pem','wb')f.write(private_pem) # 将字节流写入文件f.close() 加解密，两种填充方式:一种是 PKCS1_v1_5，另一种是 PKCS1_OAEP1234567891011121314151617181920212223242526from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5import base64def rsa_encrypt(plain): with open('public.pem','rb') as f: data = f.read() key = RSA.importKey(data) rsa = PKCS1_v1_5.new(key) cipher = rsa.encrypt(plain) return base64.b64encode(cipher)def rsa_decrypt(cipher): with open('private.pem','rb') as f: data = f.read() key = RSA.importKey(data) rsa = PKCS1_v1_5.new(key) plain = rsa.decrypt(base64.b64decode(cipher),'ERROR') # 'ERROR'必需 return plainif __name__ == '__main__': plain_text = b'This_is_a_test_string!' cipher = rsa_encrypt(plain_text) print(cipher) plain = rsa_decrypt(cipher) print(plain) Crypto.Util中一些常用函数123456789101112131415from Crypto.Util.number import *from Crypto.Util.Padding import *# 按照规定的几种类型 pad，自定义 pad可以用 ljust()或者 zfill()str1 = b'helloworld'pad_str1 = pad(str1,16,'pkcs7') # 填充类型默认为'pkcs7'，还有'iso7816'和'x923'print(unpad(pad_str1,16))# numberprint(GCD(11,143)) # 最大公约数print(bytes_to_long(b'hello')) # 字节转整数print(long_to_bytes(0x41424344)) # 整数转字节print(getPrime(16)) # 返回一个最大为 N bit 的随机素数print(getStrongPrime(512)) # 返回强素数print(inverse(10,5)) # 求逆元print(isPrime(1227)) # 判断是不是素数 Hash算法123456789# coding=utf-8import hashlib# 除了sha1还有sha224,sha256,sha384,sha3_224,sha3_256,sha3_384,sha3_512,sha512,md5hash = hashlib.sha1()hash.update('admin'.encode('utf-8'))print(hash.hexdigest())# print(hash.digest())# 在pythnon3中将hex转为字符串的# bytes.fromhex('64').decode('utf-8') -&gt; d 加盐HASH123hash = hashlib.md5('python'.encode('utf-8'))hash.update('admin'.encode('utf-8'))print(hash.hexdigest()) 获取文件md5：123456789101112131415161718import hashlibdef md5sum(filename): """ 用于获取文件的md5值 :param filename: 文件名 :return: MD5码 """ if not os.path.isfile(filename): # 如果校验md5的文件不是文件，返回空 return myhash = hashlib.md5() f = open(filename, 'rb') while True: b = f.read(8096) if not b: break myhash.update(b) f.close() return myhash.hexdigest() RC4python版本12345678910from Crypto.Cipher import ARC4def myRC4(data,key): rc41 = ARC4.new(key) encrypted = rc41.encrypt(data) return encrypted.encode('hex').upper()s = "helloworld"key = "this_is_key"enc = myRC4(s, key)print encprint myRC4(enc.decode('hex'), key) c版本1234567891011121314151617181920212223242526272829303132void rc4_init(unsigned char *s, unsigned char *key, unsigned long Len) //初始化函数&#123; int i =0, j = 0; char k[256] = &#123;0&#125;; unsigned char tmp = 0; for (i=0;i&lt;256;i++) &#123; s[i] = i; k[i] = key[i%Len]; &#125; for (i=0; i&lt;256; i++) &#123; j=(j+s[i]+k[i])%256; tmp = s[i]; s[i] = s[j]; //交换s[i]和s[j] s[j] = tmp; &#125; &#125;void rc4_crypt(unsigned char *s, unsigned char *Data, unsigned long Len) //加解密&#123; int i = 0, j = 0, t = 0; unsigned long k = 0; unsigned char tmp; for(k=0;k&lt;Len;k++) &#123; i=(i+1)%256; j=(j+s[i])%256; tmp = s[i]; s[i] = s[j]; //交换s[x]和s[y] s[j] = tmp; t=(s[i]+s[j])%256; Data[k] ^= s[t]; &#125;&#125; 通过分析初始化代码，可以看出初始化代码中，对字符数组 s 进行了初始化赋值，且赋值分别递增。之后对 s 进行了 256 次交换操作。通过识别初始化代码，可以知道 rc4 算法。其伪代码表示为：初始化长度为 256 的 S 盒。第一个 for 循环将 0 到 255 的互不重复的元素装入 S 盒。第二个 for 循环根据密钥打乱 S 盒。12345678for i from 0 to 255 S[i] := iendforj := 0for( i=0 ; i&lt;256 ; i++) j := (j + S[i] + key[i mod keylength]) % 256 swap values of S[i] and S[j]endfor 下面 i,j 是两个指针。每收到一个字节，就进行 while 循环。通过一定的算法（(a),(b)）定位 S 盒中的一个元素，并与输入字节异或，得到 k。循环中还改变了 S 盒。如果输入的是明文，输出的就是密文；如果输入的是密文，输出的就是明文。123456789i := 0j := 0while GeneratingOutput: i := (i + 1) mod 256 //a j := (j + S[i]) mod 256 //b swap values of S[i] and S[j] //c k := inputByte ^ S[(S[i] + S[j]) % 256] output Kendwhile 此算法保证每 256 次循环中 S 盒的每个元素至少被交换过一次 md5爆破12345678910111213141516import hashlibtotal = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\&quot;#$%&amp;\\&apos;()*+,-./:;&lt;=&gt;?@[\\\\]^_`&#123;|&#125;~ \\t\\n\\r\\x0b\\x0c&quot;def getXXXX(digist): for a in range(256): for b in range(256): for c in range(256): for d in range(256): XXXX = bytes([a,b,c,d]) if a+b+c+d == 0: print XXXX print hashlib.md5(XXXX).hexdigest() if hashlib.md5(XXXX).hexdigest() == digist: return [a, b, c, d] return [0,0,0,0]s = &quot;2061e19de42da6e0de934592a2de3ca0&quot;XXXX = getXXXX(s) Tea算法过程:python版本:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from ctypes import *class Tea: def __init__(self): self.delta = 0x9e3779b9 self.sum = 0xc6ef3720 def encipher(self, v, k): y = c_uint32(v[0]) z = c_uint32(v[1]) sum = c_uint32(0) delta = 0x9e3779b9 n = 32 w = [0,0] while(n&gt;0): sum.value += delta y.value += ( z.value &lt;&lt; 4 ) + k[0] ^ z.value + sum.value ^ ( z.value &gt;&gt; 5 ) + k[1] z.value += ( y.value &lt;&lt; 4 ) + k[2] ^ y.value + sum.value ^ ( y.value &gt;&gt; 5 ) + k[3] n -= 1 w[0] = y.value w[1] = z.value return w def decipher(self, v, k): y = c_uint32(v[0]) z = c_uint32(v[1]) sum = c_uint32(0xc6ef3720) delta = 0x9e3779b9 n = 32 w = [0,0] while(n&gt;0): z.value -= ( y.value &lt;&lt; 4 ) + k[2] ^ y.value + sum.value ^ ( y.value &gt;&gt; 5 ) + k[3] y.value -= ( z.value &lt;&lt; 4 ) + k[0] ^ z.value + sum.value ^ ( z.value &gt;&gt; 5 ) + k[1] sum.value -= delta n -= 1 w[0] = y.value w[1] = z.value return wif __name__ == "__main__": k = [1,2,3,4] v = [1385482522,639876499] tea = Tea() enc = tea.encipher(v, k) print(enc) dec = tea.decipher(enc, k) print(dec) c版本:12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; //加密函数 void encrypt (uint32_t* v, uint32_t* k) &#123; uint32_t v0=v[0], v1=v[1], sum=0, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i &lt; 32; i++) &#123; /* basic cycle start */ sum += delta; v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); &#125; /* end cycle */ v[0]=v0; v[1]=v1; &#125; //解密函数 void decrypt (uint32_t* v, uint32_t* k) &#123; uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i&lt;32; i++) &#123; /* basic cycle start */ v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); sum -= delta; &#125; /* end cycle */ v[0]=v0; v[1]=v1; &#125; int main() &#123; uint32_t v[2]=&#123;1,2&#125;,k[4]=&#123;2,2,3,4&#125;; // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf("加密前原始数据：%u %u\n",v[0],v[1]); encrypt(v, k); printf("加密后的数据：%u %u\n",v[0],v[1]); decrypt(v, k); printf("解密后的数据：%u %u\n",v[0],v[1]); return 0; &#125; XTEA算法实现1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; /* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */ void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9; for (i=0; i &lt; num_rounds; i++) &#123; v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); sum += delta; v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]); &#125; v[0]=v0; v[1]=v1; &#125; void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds; for (i=0; i &lt; num_rounds; i++) &#123; v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); &#125; v[0]=v0; v[1]=v1; &#125; int main() &#123; uint32_t v[2]=&#123;1,2&#125;; uint32_t const k[4]=&#123;2,2,3,4&#125;; unsigned int r=32;//num_rounds建议取值为32 // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf("加密前原始数据：%u %u\n",v[0],v[1]); encipher(r, v, k); printf("加密后的数据：%u %u\n",v[0],v[1]); decipher(r, v, k); printf("解密后的数据：%u %u\n",v[0],v[1]); return 0; &#125; XXTEA算法过程:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #define DELTA 0x9e3779b9 #define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z))) void btea(uint32_t *v, int n, uint32_t const key[4]) &#123; uint32_t y, z, sum; unsigned p, rounds, e; if (n &gt; 1) /* Coding Part */ &#123; rounds = 6 + 52/n; sum = 0; z = v[n-1]; do &#123; sum += DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p=0; p&lt;n-1; p++) &#123; y = v[p+1]; z = v[p] += MX; &#125; y = v[0]; z = v[n-1] += MX; &#125; while (--rounds); &#125; else if (n &lt; -1) /* Decoding Part */ &#123; n = -n; rounds = 6 + 52/n; sum = rounds*DELTA; y = v[0]; do &#123; e = (sum &gt;&gt; 2) &amp; 3; for (p=n-1; p&gt;0; p--) &#123; z = v[p-1]; y = v[p] -= MX; &#125; z = v[n-1]; y = v[0] -= MX; sum -= DELTA; &#125; while (--rounds); &#125; &#125; int main() &#123; uint32_t v[2]= &#123;1,2&#125;; uint32_t const k[4]= &#123;2,2,3,4&#125;; int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密 // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf("加密前原始数据：%u %u\n",v[0],v[1]); btea(v, n, k); printf("加密后的数据：%u %u\n",v[0],v[1]); btea(v, -n, k); printf("解密后的数据：%u %u\n",v[0],v[1]); return 0; &#125; 服务器交互123456789101112131415from pwn import *p = remote(&apos;47.111.59.243&apos;,9421)guessmd5 = p.recvline()print guessmd5XXXX = getXXXX(guessmd5)p.recvuntil(&apos;&gt; &apos;)p.sendline(XXXX)io.sendlineafter(&quot;token&quot;, &quot;your token&quot;)def solve(p, idx, ans): log.info(&quot;solve &#123;&#125;&quot;.format(idx)) p.sendlineafter(&quot;you want to play?&quot;, str(idx)) p.sendlineafter(&quot;Your answer:&quot;, ans)solve(io, 20, &quot;[0, 0.0, False, 0j,-0.0,-0j,-0.0-0j]&quot;) //是USTC的校赛题,python种0的7种写法hhh]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idc]]></title>
    <url>%2F2019%2F11%2F05%2Fidc%2F</url>
    <content type="text"><![CDATA[读取和修改数据long Byte(long addr)，从虚拟地址addr 处读取一个字节值。long Word(long addr)，从虚拟地址addr 处读取一个字（2 字节）值。long Dword(long addr)，从虚拟地址addr 处读取一个双字（4 字节）值。void PatchByte(long addr, long val)，设置虚拟地址addr 处的一个字节值。void PatchWord(long addr, long val)，设置虚拟地址addr 处的一个字值。void PatchDword(long addr, long val)，设置虚拟地址addr 处的一个双字值。bool isLoaded(long addr)，如果addr 包含有效数据，则返回1，否则返回0。 在读取和写入数据库时，这里的每一个函数都考虑到了当前处理器模块的字节顺序（小端或大端）。PatchXXX 函数还根据被调用的函数，通过仅使用适当数量的低位字节，将所提供的值调整到适当大小。例如，调用PatchByte(0x401010, 0x1234)将使用字节值0x34（0x1234 的低位字节）修改0x401010 位置。如果在用Byte、Word 和Dword 读取数据库时提供了一个无效的地址，它们将分别返回值0xFF、0xFFFF 和0xFFFFFFFF。因为你没有办法将这些错误值与存储在数据库中的合法值区分开来，因此，在尝试从数据库中的某个地址读取数据之前，你可能希望调用isLoaded 函数，以确定这个地址是否包含任何数据。 用户交互函数void Message(string format, …)，在输出窗口打印一条格式化消息。这个函数类似于C 语言的printf 函数，并接受printf 风格的格式化字符串。void print(…)，在输出窗口中打印每个参数的字符串表示形式。void Warning(string format, …)，在对话框中显示一条格式化消息。string AskStr(string default, string prompt)，显示一个输入框，要求用户输入一个字符串值。如果操作成功，则返回用户的字符串；如果对话框被取消，则返回0。string AskFile(long doSave, string mask, string prompt)，显示一个文件选择对话框，以简化选择文件的任务。你可以创建新文件保存数据（doSave=1），或选择现有的文件读取数据（doSave=0）。你可以根据mask（如.或*.idc）过滤显示的文件列表。如果操作成功，则返回选定文件的名称；如果对话框被取消，则返回0。long AskYN(long default, string prompt)，用一个答案为“是”或“否”的问题提示用户，突出一个默认的答案（1 为是，0 为否，-1 为取消）。返回值是一个表示选定答案的整数。long ScreenEA()，返回当前光标所在位置的虚拟地址。bool Jump(long addr)，跳转到反汇编窗口的指定地址。 字符串操纵函数string form(string format, …)//preIDA5.6，返回一个新字符串，该字符串根据所提供的格式化字符串和值进行格式化。这个函数基本上等同于C 语言的sprintf 函数。string sprintf(string format,…)//IDA5.6+，在IDA5.6 中，sprintf 用于替代form（参见上面）。long atol(string val)，将十进制值val 转换成对应的整数值。long xtol(string val)，将十六进制值val（可选择以0x 开头）转换成对应的整数值。string ltoa(long val, long radix)，以指定的radix（2、8、10 或16）返回val 的字符串值。long ord(string ch)，返回单字符字符串ch 的ASCII 值。long strlen(string str)，返回所提供字符串的长度。long strstr(string str, string substr)，返回str 中substr 的索引。如果没有发现子字符串，则返回-1。string substr(string str, long start, long end)，返回包含str 中由start 到end-1位置的字符的子字符串。如果使用分片（ IDA5.6 及更高版本）， 此函数等同于str[start:end]。 文件输入/输出函数long fopen(string filename, string mode)，返回一个整数文件句柄（如果发生错误，则返回0），供所有IDC 文件输入/输出函数使用。mode 参数与C 语言的fopen 函数使用的模式（r 表示读取，w 表示写入，等等）类似。void fclose(long handle)，关闭fopen 中文件句柄指定的文件。long filelength(long handle)，返回指定文件的长度，如果发生错误，则返回-1。long fgetc(long handle)，从给定文件中读取一个字节。如果发生错误，则返回-1。long fputc(long val, long handle)，写入一个字节到给定文件中。如果操作成功，则返回0；如果发生错误，则返回-1。long fprintf(long handle, string format, …)，将一个格式化字符串写入到给定文件中。long writestr(long handle, string str)，将指定的字符串写入到给定文件中。string/long readstr(long handle)，从给定文件中读取一个字符串。这个函数读取到下一个换行符为止的所有字符（包括非ASCII 字符），包括换行符本身（ASCII 0xA）。如果操作成功，则返回字符串；如果读取到文件结尾，则返回-1。long writelong(long handle, long val, long bigendian)，使用大端（bigendian=1）或小端（bigendian=0）字节顺序将一个4 字节整数写入到给定文件。long readlong(long handle, long bigendian)，使用大端（bigendian=1）或小端（bigendian=0）字节顺序从给定的文件中读取一个4 字节整数。long writeshort(long handle, long val, long bigendian)，使用大端（bigendian=1）或小端（bigendian=0）字节顺序将一个2 字节整数写入到给定的文件。long readshort(long handle, long bigendian)，使用大端（bigendian=1）或小端（bigendian=0）字节顺序从给定的文件中读取一个2 字节整数。bool loadfile(long handle, long pos, long addr, long length)，从给定文件的pos 位置读取length 数量的字节，并将这些字节写入到以addr 地址开头的数据库中。bool savefile(long handle, long pos, long addr, long length)，将以addr 数据库地址开头的length 数量的字节写入给定文件的pos 位置。 操纵数据库名称下面IDC函数用于处理IDA数据库中已命名的位置。string Name(long addr)，返回与给定地址有关的名称，如果该位置没有名称，则返回空字符串。如果名称被标记为局部名称，这个函数并不返回用户定义的名称。string NameEx(long from, long addr)，返回与addr 有关的名称。如果该位置没有名称，则返回空字符串。如果from 是一个同样包含addr 的函数中的地址，则这个函数返回用户定义的局部名称。bool MakeNameEx(long addr, string name, long flags)，将给定的名称分配给给定的地址。该名称使用flags 位掩码中指定的属性创建而成。这些标志在帮助系统中的MakeNameEx 文档中有记载描述，可用于指定各种属性，如名称是局部名称还是公共名称、名称是否应在名称窗口中列出。long LocByName(string name)，返回一个位置（名称已给定）的地址。如果数据库中没有这个名称，则返回BADADDR（-1）。long LocByNameEx(long funcaddr, string localname)，在包含funcaddr 的函数中搜索给定的局部名称。如果给定的函数中没有这个名称，则返回BADADDR（-1）。 处理函数long GetFunctionAttr(long addr, long attrib)，返回包含给定地址的函数的被请求的属性。请参考IDC 帮助文档了解属性常量。例如，要查找一个函数的结束地址，可以使用GetFunctionAttr(addr, FUNCATTR_END);。string GetFunctionName(long addr)，返回包含给定地址的函数的名称。如果给定的地址并不属于一个函数，则返回一个空字符串。long NextFunction(long addr)，返回给定地址后的下一个函数的起始地址。如果数据库中给定地址后没有其他函数，则返回-1。long PrevFunction(long addr)，返回给定地址之前距离最近的函数的起始地址。如果在给定地址之前没有函数，则返回-1。 代码交叉引用函数long Rfirst(long from)，返回给定地址向其转交控制权的第一个位置。如果给定的地址没有引用其他地址，则返回BADADDR（-1）。long Rnext(long from, long current)，如果current 已经在前一次调用Rfirst 或Rnext时返回，则返回给定地址（from）转交控制权的下一个位置。如果没有其他交叉引用存在，则返回BADADDR。long XrefType()，返回一个常量，说明某个交叉引用查询函数（如Rfirst）返回的最后一个交叉引用的类型。对于代码交叉引用，这些常量包括fl_CN（近调用）、fl_CF（远调用）、fl_JN（近跳转）、fl_JF（远跳转）和fl_F（普通顺序流）。long RfirstB(long to)，返回转交控制权到给定地址的第一个位置。如果不存在对给定地址的交叉引用，则返回BADADDR（-1）。long RnextB(long to, long current)，如果current 已经在前一次调用RfirstB 或RnextB时返回，则返回下一个转交控制权到给定地址（to）的位置。如果不存在其他对给定位置的交叉引用，则返回BADADDR（-1）。 数据交叉引用函数long Dfirst(long from)，返回给定地址引用一个数据值的第一个位置。如果给定地址没有引用其他地址，则返回BADADDR（-1）。long Dnext(long from, long current)，如果current 已经在前一次调用Dfirst 或Dnext时返回，则返回给定地址（from）向其引用一个数据值的下一个位置。如果没有其他交叉引用存在，则返回BADADDR。long XrefType()，返回一个常量，说明某个交叉引用查询函数（如Dfirst）返回的最后一个交叉引用的类型。对于数据交叉引用，这些常量包括dr_0（提供的偏移量）、dr_W（数据写入）和dr_R（数据读取）。long DfirstB(long to)，返回将给定地址作为数据引用的第一个位置。如果不存在引用给定地址的交叉引用，则返回BADADDR（-1）。long DnextB(long to, long current)，如果currnet 已经在前一次调用DfristB 或DnextB时返回，则返回将给定地址（to）作为数据引用的下一次位置。如果没有其他对给定地址的交叉引用存在，则返回BADADDR。 数据库操纵函数void MakeUnkn(long addr, long flags)，取消位于指定地址的项的定义。这里的标志（参见IDC 的MakeUnkn 文档）指出是否也取消随后的项的定义，以及是否删除任何与取消定义的项有关的名称。相关函数MakeUnknown 允许你取消大块数据的定义。long MakeCode(long addr)，将位于指定地址的字节转换成一条指令。如果操作成功，则返回指令的长度，否则返回0。bool MakeByte(long addr)，将位于指定地址的项目转换成一个数据字节。类似的函数还包括MakeWord 和MakeDword。bool MakeComm(long addr, string comment)，在给定的地址处添加一条常规注释。bool MakeFunction(long begin, long end)，将由begin 到end 的指令转换成一个函数。如果end 被指定为BADADDR（-1），IDA 会尝试通过定位函数的返回指令，来自动确定该函数的结束地址。bool MakeStr(long begin, long end)，创建一个当前字符串（由GetStringType 返回）类型的字符串，涵盖由begin 到end-1 之间的所有字节。如果end 被指定为BADADDR，IDA会尝试自动确定字符串的结束位置。 数据库搜索函数long FindCode(long addr, long flags)，从给定的地址搜索一条指令。long FindData(long addr, long flags)，从给定的地址搜索一个数据项。long FindBinary(long addr, long flags, string binary)，从给定的地址搜索一个字节序列。字符串binary 指定一个十六进制字节序列值。如果没有设置SEARCH_CASE，且一个字节值指定了一个大写或小写ASCII 字母，则搜索仍然会匹配对应的互补值。例如，“4142”将匹配“61 62”（和“61 42”），除非你设置了SEARCH_CASE 标志。long FindText(long addr, long flags, long row, long column, string text)，在给定的地址，从给定行（row）的给定列搜索字符串text。注意，某个给定地址的反汇编文本可能会跨越几行，因此，你需要指定搜索应从哪一行开始。 反汇编行组件string GetDisasm(long addr)，返回给定地址的反汇编文本。返回的文本包括任何注释，但不包括地址信息。string GetMnem(long addr)，返回位于给定地址的指令的助记符部分。string GetOpnd(long addr, long opnum)，返回指定地址的指定操作数的文本形式。IDA以零为起始编号，从左向右对操作数编号。long GetOpType(long addr, long opnum)，返回一个整数，指出给定地址的给定操作数的类型。请参考GetOpType 的IDC 文档，了解操作数类型代码。long GetOperandValue(long addr, long opnum)，返回与给定地址的给定操作数有关的整数值。返回值的性质取决于GetOpType 指定的给定操作数的类型。string CommentEx(long addr, long type)，返回给定地址处的注释文本。如果type 为0，则返回常规注释的文本；如果type 为1，则返回可重复注释的文本。如果给定地址处没有注释，则返回一个空字符串。 给个例子1234567891011121314#include &lt;idc.idc&gt;static main()&#123; auto addr, end, locals, name, frame; addr = 0; for(addr = NextFunction(addr); addr != BADADDR; addr = NextFunction(addr)) &#123; name = Name(addr); end = GetFunctionAttr(addr, FUNCATTR_END); locals = GetFunctionAttr(addr, FUNCATTR_FRSIZE); frame = GetFrame(addr); Message(&quot;Function : %s, starts at %x, end at %x\n&quot;, name, addr, end); Message(&quot; Local variable area is %d bytes\n&quot;, locals); &#125;&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>IDA脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Upack]]></title>
    <url>%2F2019%2F10%2F03%2FUpack%2F</url>
    <content type="text"><![CDATA[Upack壳Upack是头部压缩，利用改变e_lfanew和IMAGE_FILE_HEADER.SizeOfOptionalHeader的值，在IMAGE_OPTIONAL_HEADER与IMAGE_SECTION_HEADER之间添加了额外的空间，Upack向这个区域添加加压缩代码。 OD打开Upack加壳后的exe文件如果打开可执行文件以后发现，od不能准确的找到EP，则需要手动设置。查看PE文件的ImageBase和EP的RVA，则EP的VA=ImageBase+RVA，然后转到EP处，右键选择New origin here。EP处程序如图前两条指令用于从010011B0地址读取4个字节，然后保存到EAX，此时EAX的值就是程序原本的OEP，所以可以在PUSH EAX指令后设置硬件中断。设置好硬件中断以后，F9执行指令，会直接在OEP处停下。到达OEP后选择Dump process选择Get EIP as OEP。（生成dump.exe文件后暂时不要关闭OD）此时生成的dump.exe文件还没有恢复IAT，所以无法直接运行，需要重建IAT，使用Import REC来重建IAT。选择要脱壳的可执行文件进程。填写OEP，虽然地址显示是0100739D，但是需要减去ImageBase(01000000),所以填写的地址是0000739D.填写完成后点击IAT AutoSearth自动查找到IAT地址后，点击Get Imports然后点击Fix Dump选择OD导出的dump.exe文件。生成的dump_.exe文件就是脱壳后的可执行文件。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>逆向工程核心原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-9-4]]></title>
    <url>%2F2019%2F09%2F04%2F2019-9-4%2F</url>
    <content type="text"><![CDATA[CyBRICS2019 Matreshka拿到的是JAVA字节码，在 http://www.javadecompilers.com/ 上反编译一下，得到java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.io.FileInputStream;import java.io.FileOutputStream;import javax.crypto.Cipher;import javax.crypto.SecretKeyFactory;class Code2&#123; Code2() &#123;&#125; public static byte[] decode(byte[] paramArrayOfByte, String paramString) throws Exception &#123; SecretKeyFactory localSecretKeyFactory = SecretKeyFactory.getInstance("DES"); byte[] arrayOfByte1 = paramString.getBytes(); javax.crypto.spec.DESKeySpec localDESKeySpec = new javax.crypto.spec.DESKeySpec(arrayOfByte1); javax.crypto.SecretKey localSecretKey = localSecretKeyFactory.generateSecret(localDESKeySpec); Cipher localCipher = Cipher.getInstance("DES"); localCipher.init(2, localSecretKey); byte[] arrayOfByte2 = localCipher.doFinal(paramArrayOfByte); return arrayOfByte2; &#125; public static byte[] encode(byte[] paramArrayOfByte, String paramString) throws Exception &#123; SecretKeyFactory localSecretKeyFactory = SecretKeyFactory.getInstance("DES"); byte[] arrayOfByte1 = paramString.getBytes(); javax.crypto.spec.DESKeySpec localDESKeySpec = new javax.crypto.spec.DESKeySpec(arrayOfByte1); javax.crypto.SecretKey localSecretKey = localSecretKeyFactory.generateSecret(localDESKeySpec); Cipher localCipher = Cipher.getInstance("DES"); localCipher.init(1, localSecretKey); byte[] arrayOfByte2 = localCipher.doFinal(paramArrayOfByte); return arrayOfByte2; &#125; public static void main(String[] paramArrayOfString) throws Exception &#123; String str = "matreha!"; byte[] arrayOfByte1 = encode(System.getProperty("user.name").getBytes(), str); byte[] arrayOfByte2 = &#123; 76, -99, 37, 75, -68, 10, -52, 10, -5, 9, 92, 1, 99, -94, 105, -18 &#125;; for (int i = 0; i &lt; arrayOfByte2.length; i++) &#123; if (arrayOfByte2[i] != arrayOfByte1[i]) &#123; System.out.println("No"); return; &#125; &#125; java.io.File localFile = new java.io.File("data.bin"); FileInputStream localFileInputStream = new FileInputStream(localFile); byte[] arrayOfByte3 = new byte[(int)localFile.length()]; localFileInputStream.read(arrayOfByte3); localFileInputStream.close(); byte[] arrayOfByte4 = decode(arrayOfByte3, System.getProperty("user.name")); FileOutputStream localFileOutputStream = new FileOutputStream("stage2.bin"); localFileOutputStream.write(arrayOfByte4, 0, arrayOfByte4.length); localFileOutputStream.flush(); localFileOutputStream.close(); &#125;&#125; 使用DES加密的方法，密钥是matreha。解密可以得到user.name参数是:lettreha,使用lettreha代替user.name可以将data.bin文件解密生成stage2.bin文件。 stage2.bin是一个可执行文件，使用go语言编写生成，主函数名称是main.main(在IDA中显示的结果是main_main但是gdb调试时会显示函数名称不存在，使用info function main指令查看以main开头的函数名称，显示名称时main.main，当然也可以使用b 0x00475FB0直接在main开始的地址处下断点。) emmm因为我水平不足所以后面这个我手工反编译确实看不出来…记录一下看到的两种做法。 1.根据汇编代码，发现stage2.bin文件所在的文件夹名称长度必须为17，且是根据abcdefghijklmnopq异或而来，解密代码：123456a = [0x59,0xCD,0xC9,0x90,0xE9,0x6E,0x9F,0x23,0x4B,0xAF,0x0B,0x33,0xCC,0x39,0x03,0xDB,0xA0]cp =[0x53,0xdd,0xc5,0x87,0xe4,0x63,0x99,0x14,0x4f,0xa4,0x14,0x2d,0xc4,0x24,0x04,0xc0,0xb0]key = ''for i,c in enumerate('abcdefghijklmnopq'): key += chr(ord(c) ^ a[i] ^ cp[i])print key 解密得到，文件夹名称必须为kroshka_matreshka，将stage2.bin放入kroshka_matreshka文件夹下，运行stage2.bin后得到文件result.pyc2.gdb调试123456gdb -q ./stage2.bingdb info function main*gdb disassemble main.maingdb b * 0x00476126gdb b * 0x00476181r 在运行到0x00476126的时候，执行jump 0x00476181命令，在执行过后直接r就可以得到restlt.pyc文件 使用 https://www.toolnb.com/tools-lang-en/pyc.html 这个网站反编译pyc文件得到python代码12345678910111213141516171819def decode(data, key): idx = 0 res = [] for c in data: res.append(chr(c ^ ord(key[idx]))) idx = (idx + 1) % len(key) return resflag = [ 40, 11, 82, 58, 93, 82, 64, 76, 6, 70, 100, 26, 7, 4, 123, 124, 127, 45, 1, 125, 107, 115, 0, 2, 31, 15]print('Enter key to get flag:')key = input()if len(key) != 8: print('Invalid len') quit()res = decode(flag, key)print(''.join(res)) 前几位解密出来应该是cybrics{所以可以得到key是：Kr0H4137解密出来flag为:cybrics{M4TR35HK4_15_B35T} CyBRICS2019 FastCrypto没想到别的办法，只有爆破看到了一个用popen开多线程的办法，记录一下a.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import jsonimport sysfrom egcd import egcddef get_next(a, power, N): b = pow(a,power,N) return b, b % 256key = json.loads(open('public.key').read())seed = int(sys.argv[1])def check(seed): match = False match_seed = 0 match_power = 0 for power in range(2,17): if egcd(power, key['N'])[0] != 1: continue tmp_seed = seed for _ in range(key['O']): tmp_seed = get_next(tmp_seed, power, key['N'])[0] enc = '\x46\x83\x49\x44' dec = 'RIFF' tmp_match = True for i in range(4): tmp_seed, bt = get_next(tmp_seed, power, key['N']) if ord(enc[i]) ^ bt != ord(dec[i]): tmp_match = False break if not tmp_match: continue match = True match_seed = seed match_power = power break if match: return 'True\nseed: %d\npower: %d\n' % (match_seed, match_power) else: return 'False\nseed: %d\n' % (seed)print(check(seed)) b.py(开多线程)12345678910111213141516171819202122import threadingfrom multiprocessing.dummy import Pool as ThreadPoolfrom pwn import *can_exit = Falsedef brute(i): global can_exit if can_exit: return print i context.log_level='CRITICAL' io=process(argv=['python', 'a.py', str(i)]) if 'True' in io.recvline(): res = io.recvline() res += io.recvline() can_exit = True open('res.txt','w').write(res) print res io.close()pool = ThreadPool(18)pool.map(brute, range(0,65537)) De1CTF2019 Xorz题目：1234567891011from itertools import *from data import flag,plainkey=flag.strip("de1ctf&#123;").strip("&#125;")assert(len(key)&lt;38) salt="WeAreDe1taTeam"ki=cycle(key)si=cycle(salt)cipher = ''.join([hex(ord(p) ^ ord(next(ki)) ^ ord(next(si)))[2:].zfill(2) for p in plain])print cipher# output:# 49380d773440222d1b421b3060380c3f403c3844791b202651306721135b6229294a3c3222357e766b2f15561b35305e3c3b670e49382c295c6c170553577d3a2b791470406318315d753f03637f2b614a4f2e1c4f21027e227a4122757b446037786a7b0e37635024246d60136f7802543e4d36265c3e035a725c6322700d626b345d1d6464283a016f35714d434124281b607d315f66212d671428026a4f4f79657e34153f3467097e4e135f187a21767f02125b375563517a3742597b6c394e78742c4a725069606576777c314429264f6e330d7530453f22537f5e3034560d22146831456b1b72725f30676d0d5c71617d48753e26667e2f7a334c731c22630a242c7140457a42324629064441036c7e646208630e745531436b7c51743a36674c4f352a5575407b767a5c747176016c0676386e403a2b42356a727a04662b4446375f36265f3f124b724c6e346544706277641025063420016629225b43432428036f29341a2338627c47650b264c477c653a67043e6766152a485c7f33617264780656537e5468143f305f4537722352303c3d4379043d69797e6f3922527b24536e310d653d4c33696c635474637d0326516f745e610d773340306621105a7361654e3e392970687c2e335f3015677d4b3a724a4659767c2f5b7c16055a126820306c14315d6b59224a27311f747f336f4d5974321a22507b22705a226c6d446a37375761423a2b5c29247163046d7e47032244377508300751727126326f117f7a38670c2b23203d4f27046a5c5e1532601126292f577776606f0c6d0126474b2a73737a41316362146e581d7c1228717664091c EXP:首先计算出所有可能的长度以及每个长度对应的密钥可能值，再根据词频选出最有可能性的密钥序列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#coding:utf8from itertools import cyclec="49380d773440222d1b421b3060380c3f403c3844791b202651306721135b6229294a3c3222357e766b2f15561b35305e3c3b670e49382c295c6c170553577d3a2b791470406318315d753f03637f2b614a4f2e1c4f21027e227a4122757b446037786a7b0e37635024246d60136f7802543e4d36265c3e035a725c6322700d626b345d1d6464283a016f35714d434124281b607d315f66212d671428026a4f4f79657e34153f3467097e4e135f187a21767f02125b375563517a3742597b6c394e78742c4a725069606576777c314429264f6e330d7530453f22537f5e3034560d22146831456b1b72725f30676d0d5c71617d48753e26667e2f7a334c731c22630a242c7140457a42324629064441036c7e646208630e745531436b7c51743a36674c4f352a5575407b767a5c747176016c0676386e403a2b42356a727a04662b4446375f36265f3f124b724c6e346544706277641025063420016629225b43432428036f29341a2338627c47650b264c477c653a67043e6766152a485c7f33617264780656537e5468143f305f4537722352303c3d4379043d69797e6f3922527b24536e310d653d4c33696c635474637d0326516f745e610d773340306621105a7361654e3e392970687c2e335f3015677d4b3a724a4659767c2f5b7c16055a126820306c14315d6b59224a27311f747f336f4d5974321a22507b22705a226c6d446a37375761423a2b5c29247163046d7e47032244377508300751727126326f117f7a38670c2b23203d4f27046a5c5e1532601126292f577776606f0c6d0126474b2a73737a41316362146e581d7c1228717664091c"def getCipher(c): codeintlist = [] codeintlist.extend( (map(lambda i: int(c[i:i + 2], 16), range(0, len(c), 2)))) salt="WeAreDe1taTeam" si=cycle(salt) newcodeintlist = [ci ^ ord(next(si)) for ci in codeintlist] return newcodeintlistdef getKeyPool(cipher, stepSet, plainSet, keySet): ''' 传入的密文串、明文字符集、密钥字符集、密钥长度范围均作为数字列表处理.形如[0x11,0x22,0x33] 返回一个字典，以可能的密钥长度为键，以对应的每一字节的密钥字符集构成的列表为值，密钥字符集为数字列表。 形如&#123; 1:[[0x11]], 3:[ [0x11,0x33,0x46], [0x22,0x58], [0x33] ] &#125; ''' keyPool = dict() for step in stepSet: maybe = [None] * step for pos in xrange(step): maybe[pos] = [] for k in keySet: flag = 1 for c in cipher[pos::step]: if c ^ k not in plainSet: flag = 0 if flag: maybe[pos].append(k) for posPool in maybe: if len(posPool) == 0: maybe = [] break if len(maybe) != 0: keyPool[step] = maybe return keyPooldef calCorrelation(cpool): '''传入字典，形如&#123;'e':2,'p':3&#125; 返回可能性，0~1,值越大可能性越大 (correlation between the decrypted column letter frequencies and the relative letter frequencies for normal English text) ''' frequencies = &#123;"e": 0.12702, "t": 0.09056, "a": 0.08167, "o": 0.07507, "i": 0.06966, "n": 0.06749, "s": 0.06327, "h": 0.06094, "r": 0.05987, "d": 0.04253, "l": 0.04025, "c": 0.02782, "u": 0.02758, "m": 0.02406, "w": 0.02360, "f": 0.02228, "g": 0.02015, "y": 0.01974, "p": 0.01929, "b": 0.01492, "v": 0.00978, "k": 0.00772, "j": 0.00153, "x": 0.00150, "q": 0.00095, "z": 0.00074&#125; relative = 0.0 total = 0 fpool = 'etaoinshrdlcumwfgypbvkjxqz' total = sum(cpool.values()) # 总和应包括字母和其他可见字符 for i in cpool.keys(): if i in fpool: relative += frequencies[i] * cpool[i] / total return relative# 分析最有可能性的密钥序列def analyseFrequency(cfreq): key = [] for posFreq in cfreq: mostRelative = 0 for keyChr in posFreq.keys(): r = calCorrelation(posFreq[keyChr]) if r &gt; mostRelative: mostRelative = r keychar = keyChr key.append(keychar) return keydef getFrequency(cipher, keyPoolList): ''' 传入的密文作为数字列表处理 传入密钥的字符集应为列表，依次包含各字节字符集。 形如[[0x11,0x12],[0x22]] 返回字频列表，依次为各字节字符集中每一字符作为密钥组成部分时对应的明文字频 形如[&#123; 0x11:&#123;'a':2,'b':3&#125;, 0x12:&#123;'e':6&#125; &#125;, &#123; 0x22:&#123;'g':1&#125; &#125;] ''' freqList = [] keyLen = len(keyPoolList) for i in xrange(keyLen): posFreq = dict() for k in keyPoolList[i]: posFreq[k] = dict() for c in cipher[i::keyLen]: p = chr(k ^ c) posFreq[k][p] = posFreq[k][p] + 1 if p in posFreq[k] else 1 freqList.append(posFreq) return freqList# 解密def vigenereDecrypt(cipher, key): plain = '' cur = 0 ll = len(key) for c in cipher: plain += chr(c ^ key[cur]) cur = (cur + 1) % ll return plaindef main(): ps = [] ks = [] ss = [] ps.extend(xrange(32, 127)) ks.extend(xrange(0xff + 1)) ss.extend(xrange(38)) cipher = getCipher(c) keyPool = getKeyPool(cipher=cipher, stepSet=ss, plainSet=ps, keySet=ks) for i in keyPool: freq = getFrequency(cipher, keyPool[i]) key = analyseFrequency(freq) plain = vigenereDecrypt(cipher, key) print plain,"\n" print ''.join(map(chr,key))if __name__ == '__main__': main()# output: Wvlc0m3tOjo1nu55un1ojOt3q0cl3W 修正后得到flag# data文件实际内容：# flag="de1ctf&#123;W3lc0m3tOjo1nu55un1ojOt3m0cl3W&#125;"# plain="In faith I do not love thee with mine eyes,For they in thee a thousand errors note;But `tis my heart that loves what they despise,Who in despite of view is pleased to dote.Nor are mine ears with thy tongue`s tune delighted;Nor tender feeling to base touches prone,Nor taste, nor smell, desire to be invitedTo any sensual feast with thee alone.But my five wits, nor my five senses canDissuade one foolish heart from serving thee,Who leaves unswayed the likeness of a man,Thy proud heart`s slave and vassal wretch to be.Only my plague thus far I count my gain,That she that makes me sin awards me pain." De1CTF2019 BabyRSA有一篇CTF中RSA的解题套路 https://err0rzz.github.io/2017/11/14/CTF%E4%B8%ADRSA%E5%A5%97%E8%B7%AF/加一篇先知社区的 https://xz.aliyun.com/t/2446题目：1234567891011121314151617181920212223242526272829303132import binasciifrom data import e1,e2,p,q1p,q1q,hint,flagn = [20129615352491765499340112943188317180548761597861300847305827141510465619670536844634558246439230371658836928103063432870245707180355907194284861510906071265352409579441048101084995923962148527097370705452070577098780246282820065573711015664291991372085157016901209114191068574208680397710042842835940428451949500607613634682684113208766694028789275748528254287705759528498986306494267817198340658241873024800336013946294891687591013414935237821291805123285905335762719823771647853378892868896078424572232934360940672962436849523915563328779942134504499568866135266628078485232098208237036724121481835035731201383423L, 31221650155627849964466413749414700613823841060149524451234901677160009099014018926581094879840097248543411980533066831976617023676225625067854003317018794041723612556008471579060428898117790587991055681380408263382761841625714415879087478072771968160384909919958010983669368360788505288855946124159513118847747998656422521414980295212646675850690937883764000571667574381419144372824211798018586804674824564606122592483286575800685232128273820087791811663878057827386379787882962763290066072231248814920468264741654086011072638211075445447843691049847262485759393290853117072868406861840793895816215956869523289231421L, 29944537515397953361520922774124192605524711306753835303703478890414163510777460559798334313021216389356251874917792007638299225821018849648520673813786772452822809546571129816310207232883239771324122884804993418958309460009406342872173189008449237959577469114158991202433476710581356243815713762802478454390273808377430685157110095496727966308001254107517967559384019734279861840997239176254236069001453544559786063915970071130087811123912044312219535513880663913831358790376650439083660611831156205113873793106880255882114422025746986403355066996567909581710647746463994280444700922867397754748628425967488232530303L, 25703437855600135215185778453583925446912731661604054184163883272265503323016295700357253105301146726667897497435532579974951478354570415554221401778536104737296154316056314039449116386494323668483749833147800557403368489542273169489080222009368903993658498263905567516798684211462607069796613434661148186901892016282065916190920443378756167250809872483501712225782004396969996983057423942607174314132598421269169722518224478248836881076484639837343079324636997145199835034833367743079935361276149990997875905313642775214486046381368619638551892292787783137622261433528915269333426768947358552919740901860982679180791L]c = [19131432661217908470262338421299691998526157790583544156741981238822158563988520225986915234570037383888112724408392918113942721994125505014727545946133307329781747600302829588248042922635714391033431930411180545085316438084317927348705241927570432757892985091396044950085462429575440060652967253845041398399648442340042970814415571904057667028157512971079384601724816308078631844480110201787343583073815186771790477712040051157180318804422120472007636722063989315320863580631330647116993819777750684150950416298085261478841177681677867236865666207391847046483954029213495373613490690687473081930148461830425717614569L, 15341898433226638235160072029875733826956799982958107910250055958334922460202554924743144122170018355117452459472017133614642242411479849369061482860570279863692425621526056862808425135267608544855833358314071200687340442512856575278712986641573012456729402660597339609443771145347181268285050728925993518704899005416187250003304581230701444705157412790787027926810710998646191467130550713600765898234392350153965811595060656753711278308005193370936296124790772689433773414703645703910742193898471800081321469055211709339846392500706523670145259024267858368216902176489814789679472227343363035428541915118378163012031L, 18715065071648040017967211297231106538139985087685358555650567057715550586464814763683688299037897182845007578571401359061213777645114414642903077003568155508465819628553747173244235936586812445440095450755154357646737087071605811984163416590278352605433362327949048243722556262979909488202442530307505819371594747936223835233586945423522256938701002370646382097846105014981763307729234675737702252155130837154876831885888669150418885088089324534892506199724486783446267336789872782137895552509353583305880144947714110009893134162185382309992604435664777436197587312317224862723813510974493087450281755452428746194446L, 2282284561224858293138480447463319262474918847630148770112472703128549032592187797289965592615199709857879008271766433462032328498580340968871260189669707518557157836592424973257334362931639831072584824103123486522582531666152363874396482744561758133655406410364442174983227005501860927820871260711861008830120617056883514525798709601744088135999465598338635794275123149165498933580159945032363880613524921913023341209439657145962332213468573402863796920571812418200814817086234262280338221161622789516829363805084715652121739036183264026120868756523770196284142271849879003202190966150390061195469351716819539183797L]f=lambda m,e,n,c:pow(m,e,n)==cassert(sum(map(f,[p]*4,[4]*4,n,c))==4)ee1 = 42ee2 = 3ce1 = 45722651786340123946960815003059322528810481841378247280642868553607692149509126962872583037142461398806689489141741494974836882341505234255325683219092163052843461632338442529011502378931140356111756932712822516814023166068902569458299933391973504078898958921809723346229893913662577294963528318424676803942288386430172430880307619748186863890050113934573820505570928109017842647598266634344447182347849367714564686341871007505886728393751147033556889217604647355628557502208364412269944908011305064122941446516990168924709684092200183860653173856272384ce2 = 13908468332333567158469136439932325992349696889129103935400760239319454409539725389747059213835238373047899198211128689374049729578146875309231962936554403287882999967840346216695208424582739777034261079550395918048421086843927009452479936045850799096750074359160775182238980989229190157551197830879877097703347301072427149474991803868325769967332356950863518504965486565464059770451458557744949735282131727956056279292800694203866167270268988437389945703117070604488999247750139568614939965885211276821987586882908159585863514561191905040244967655444219603287214405014887994238259270716355378069726760953320025828158tmp = 864078778078609835167779565982540757684070450697854309005171742813414963447462554999012718960925081621571487444725528982424037419052194840720949809891134854871222612682162490991065015935449289960707882463387n = 15911581555796798614711625288508309704791837516232122410440958830726078821069050404012820896260071751380436992710638364294658173571101596931605797509712839622479368850251206419748090059752427303611760004621378226431226983665746837779056271530181865648115862947527212787824629516204832313026456390047768174765687040950636530480549014401279054346098030395100387004111574278813749630986724706263655166289586230453975953773791945408589484679371854113457758157492241225180907090235116325034822993748409011554673180494306003272836905082473475046277554085737627846557240367696214081276345071055578169299060706794192776825039assert(pow(e1,ee1,n)==ce1)assert(pow(e2+tmp,ee2,n)==ce2)e = 46531n = 16278524034278364842964386062476113517067911891699789991355982121084973951738324063305190630865511554888330215827724887964565979607808294168282995825864982603759381323048907814961279012375346497781046417204954101076457350988751188332353062731641153547102721113593787978587135707313755661153376485647168543680503160420091693269984008764444291289486805840439906620313162344057956594836197521501755378387944609246120662335790110901623740990451586621846212047950084207251595169141015645449217847180683357626383565631317253913942886396494396189837432429078251573229378917400841832190737518763297323901586866664595327850603c = 14992132140996160330967307558503117255626925777426611978518339050671013041490724616892634911030918360867974894371539160853827180596100892180735770688723270765387697604426715670445270819626709364566478781273676115921657967761494619448095207169386364541164659123273236874649888236433399127407801843412677293516986398190165291102109310458304626261648346825196743539220198199366711858135271877662410355585767124059539217274691606825103355310348607611233052725805236763220343249873849646219850954945346791015858261715967952461021650307307454434510851869862964236227932964442289459508441345652423088404453536608812799355469hint=int(binascii.hexlify(hint),16)assert(q1p*q1q==n)assert(q1p&lt;q1q)assert(c==pow(hint,e,n))flag=int(binascii.hexlify(flag),16)q1=q1pq2 = 114401188227479584680884046151299704656920536168767132916589182357583461053336386996123783294932566567773695426689447410311969456458574731187512974868297092638677515283584994416382872450167046416573472658841627690987228528798356894803559278308702635288537653192098514966089168123710854679638671424978221959513c1 = 262739975753930281690942784321252339035906196846340713237510382364557685379543498765074448825799342194332681181129770046075018122033421983227887719610112028230603166527303021036386350781414447347150383783816869784006598225583375458609586450854602862569022571672049158809874763812834044257419199631217527367046624888837755311215081173386523806086783266198390289097231168172692326653657393522561741947951887577156666663584249108899327053951891486355179939770150550995812478327735917006194574412518819299303783243886962455399783601229227718787081785391010424030509937403600351414176138124705168002288620664809270046124c2 = 7395591129228876649030819616685821899204832684995757724924450812977470787822266387122334722132760470911599176362617225218345404468270014548817267727669872896838106451520392806497466576907063295603746660003188440170919490157250829308173310715318925771643105064882620746171266499859049038016902162599261409050907140823352990750298239508355767238575709803167676810456559665476121149766947851911064706646506705397091626648713684511780456955453552020460909638016134124590438425738826828694773960514221910109473941451471431637903182205738738109429736425025621308300895473186381826756650667842656050416299166317372707709596assert(c1==pow(flag,e1,p*q1))assert(c2==pow(flag,e2,p*q2)) 首先第一步，根据第一个等式条件可以使用中国剩余定理求出p^4，开方可以求出p的值。第二步，因为ee1和ee2的值比较小，可以使用低加密指数攻击的方式求出e1,e2第三步，使用yafu对n进行分解可以求出q1p, q1q第四步，因为gcd(e1, pq1)==14 and gcd(e2, pq2)==14,在e与n不互素的时候并不能求出唯一的d使得e*d mod n == 1根据这篇文章可以在e与n不互素的时候求解 https://blog.csdn.net/chenzzhenguo/article/details/94339659exp:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import binascii, gmpy2n = [20129615352491765499340112943188317180548761597861300847305827141510465619670536844634558246439230371658836928103063432870245707180355907194284861510906071265352409579441048101084995923962148527097370705452070577098780246282820065573711015664291991372085157016901209114191068574208680397710042842835940428451949500607613634682684113208766694028789275748528254287705759528498986306494267817198340658241873024800336013946294891687591013414935237821291805123285905335762719823771647853378892868896078424572232934360940672962436849523915563328779942134504499568866135266628078485232098208237036724121481835035731201383423L, 31221650155627849964466413749414700613823841060149524451234901677160009099014018926581094879840097248543411980533066831976617023676225625067854003317018794041723612556008471579060428898117790587991055681380408263382761841625714415879087478072771968160384909919958010983669368360788505288855946124159513118847747998656422521414980295212646675850690937883764000571667574381419144372824211798018586804674824564606122592483286575800685232128273820087791811663878057827386379787882962763290066072231248814920468264741654086011072638211075445447843691049847262485759393290853117072868406861840793895816215956869523289231421L, 29944537515397953361520922774124192605524711306753835303703478890414163510777460559798334313021216389356251874917792007638299225821018849648520673813786772452822809546571129816310207232883239771324122884804993418958309460009406342872173189008449237959577469114158991202433476710581356243815713762802478454390273808377430685157110095496727966308001254107517967559384019734279861840997239176254236069001453544559786063915970071130087811123912044312219535513880663913831358790376650439083660611831156205113873793106880255882114422025746986403355066996567909581710647746463994280444700922867397754748628425967488232530303L, 25703437855600135215185778453583925446912731661604054184163883272265503323016295700357253105301146726667897497435532579974951478354570415554221401778536104737296154316056314039449116386494323668483749833147800557403368489542273169489080222009368903993658498263905567516798684211462607069796613434661148186901892016282065916190920443378756167250809872483501712225782004396969996983057423942607174314132598421269169722518224478248836881076484639837343079324636997145199835034833367743079935361276149990997875905313642775214486046381368619638551892292787783137622261433528915269333426768947358552919740901860982679180791L]c = [19131432661217908470262338421299691998526157790583544156741981238822158563988520225986915234570037383888112724408392918113942721994125505014727545946133307329781747600302829588248042922635714391033431930411180545085316438084317927348705241927570432757892985091396044950085462429575440060652967253845041398399648442340042970814415571904057667028157512971079384601724816308078631844480110201787343583073815186771790477712040051157180318804422120472007636722063989315320863580631330647116993819777750684150950416298085261478841177681677867236865666207391847046483954029213495373613490690687473081930148461830425717614569L, 15341898433226638235160072029875733826956799982958107910250055958334922460202554924743144122170018355117452459472017133614642242411479849369061482860570279863692425621526056862808425135267608544855833358314071200687340442512856575278712986641573012456729402660597339609443771145347181268285050728925993518704899005416187250003304581230701444705157412790787027926810710998646191467130550713600765898234392350153965811595060656753711278308005193370936296124790772689433773414703645703910742193898471800081321469055211709339846392500706523670145259024267858368216902176489814789679472227343363035428541915118378163012031L, 18715065071648040017967211297231106538139985087685358555650567057715550586464814763683688299037897182845007578571401359061213777645114414642903077003568155508465819628553747173244235936586812445440095450755154357646737087071605811984163416590278352605433362327949048243722556262979909488202442530307505819371594747936223835233586945423522256938701002370646382097846105014981763307729234675737702252155130837154876831885888669150418885088089324534892506199724486783446267336789872782137895552509353583305880144947714110009893134162185382309992604435664777436197587312317224862723813510974493087450281755452428746194446L, 2282284561224858293138480447463319262474918847630148770112472703128549032592187797289965592615199709857879008271766433462032328498580340968871260189669707518557157836592424973257334362931639831072584824103123486522582531666152363874396482744561758133655406410364442174983227005501860927820871260711861008830120617056883514525798709601744088135999465598338635794275123149165498933580159945032363880613524921913023341209439657145962332213468573402863796920571812418200814817086234262280338221161622789516829363805084715652121739036183264026120868756523770196284142271849879003202190966150390061195469351716819539183797L]def CRT(mi, ai): assert(isinstance(mi, list) and isinstance(ai, list)) assert(reduce(gmpy2.gcd, mi) == 1) # mi之间互素 M = reduce(lambda x, y: x * y, mi) ai_ti_Mi = [a * (M / m) * gmpy2.invert(M / m, m) for (m, a) in zip(mi, ai)] return reduce(lambda x, y: x + y, ai_ti_Mi) % Mp = gmpy2.iroot(CRT(n, c), 4)[0] # iroot开n次方，第一个返回值是结果，第二个返回值是是否为整数print "p = ", pee1 = 42ee2 = 3ce1 = 45722651786340123946960815003059322528810481841378247280642868553607692149509126962872583037142461398806689489141741494974836882341505234255325683219092163052843461632338442529011502378931140356111756932712822516814023166068902569458299933391973504078898958921809723346229893913662577294963528318424676803942288386430172430880307619748186863890050113934573820505570928109017842647598266634344447182347849367714564686341871007505886728393751147033556889217604647355628557502208364412269944908011305064122941446516990168924709684092200183860653173856272384ce2 = 13908468332333567158469136439932325992349696889129103935400760239319454409539725389747059213835238373047899198211128689374049729578146875309231962936554403287882999967840346216695208424582739777034261079550395918048421086843927009452479936045850799096750074359160775182238980989229190157551197830879877097703347301072427149474991803868325769967332356950863518504965486565464059770451458557744949735282131727956056279292800694203866167270268988437389945703117070604488999247750139568614939965885211276821987586882908159585863514561191905040244967655444219603287214405014887994238259270716355378069726760953320025828158tmp = 864078778078609835167779565982540757684070450697854309005171742813414963447462554999012718960925081621571487444725528982424037419052194840720949809891134854871222612682162490991065015935449289960707882463387n = 15911581555796798614711625288508309704791837516232122410440958830726078821069050404012820896260071751380436992710638364294658173571101596931605797509712839622479368850251206419748090059752427303611760004621378226431226983665746837779056271530181865648115862947527212787824629516204832313026456390047768174765687040950636530480549014401279054346098030395100387004111574278813749630986724706263655166289586230453975953773791945408589484679371854113457758157492241225180907090235116325034822993748409011554673180494306003272836905082473475046277554085737627846557240367696214081276345071055578169299060706794192776825039for i in xrange(200000): if gmpy2.iroot(ce1+n*i, ee1)[1] == 1: e1 = gmpy2.iroot(ce1+n*i, ee1)[0] breakfor i in xrange(200000): if gmpy2.iroot(ce2+n*i, ee2)[1] == 1: e2 = gmpy2.iroot(ce2+n*i, ee2)[0] - tmp breakprint "e1 = ", e1print "e2 = ", e2e = 46531n = 16278524034278364842964386062476113517067911891699789991355982121084973951738324063305190630865511554888330215827724887964565979607808294168282995825864982603759381323048907814961279012375346497781046417204954101076457350988751188332353062731641153547102721113593787978587135707313755661153376485647168543680503160420091693269984008764444291289486805840439906620313162344057956594836197521501755378387944609246120662335790110901623740990451586621846212047950084207251595169141015645449217847180683357626383565631317253913942886396494396189837432429078251573229378917400841832190737518763297323901586866664595327850603c = 14992132140996160330967307558503117255626925777426611978518339050671013041490724616892634911030918360867974894371539160853827180596100892180735770688723270765387697604426715670445270819626709364566478781273676115921657967761494619448095207169386364541164659123273236874649888236433399127407801843412677293516986398190165291102109310458304626261648346825196743539220198199366711858135271877662410355585767124059539217274691606825103355310348607611233052725805236763220343249873849646219850954945346791015858261715967952461021650307307454434510851869862964236227932964442289459508441345652423088404453536608812799355469#使用yafu对n进行分解，可以得到q1p, q2pq1p = 127587319253436643569312142058559706815497211661083866592534217079310497260365307426095661281103710042392775453866174657404985539066741684196020137840472950102380232067786400322600902938984916355631714439668326671310160916766472897536055371474076089779472372913037040153356437528808922911484049460342088835693q1q = 127587319253436643569312142058559706815497211661083866592534217079310497260365307426095661281103710042392775453866174657404985539066741684196020137840472950102380232067786400322600902938984916355631714439668326671310160916766472897536055371474076089779472372913037040153356437528808922911484049460342088834871if q1p&gt;q1q: q1p,q1q=q1q,q1pphi = (q1p - 1) * (q1q - 1)assert(gmpy2.gcd(e, phi) == 1)d = gmpy2.invert(e, phi)hint = pow(c, d, n)hint = binascii.unhexlify(hex(hint)[2:])print "hint = ", hintq1 = q1pprint "q1 = ", q1q2 = 114401188227479584680884046151299704656920536168767132916589182357583461053336386996123783294932566567773695426689447410311969456458574731187512974868297092638677515283584994416382872450167046416573472658841627690987228528798356894803559278308702635288537653192098514966089168123710854679638671424978221959513c1 = 262739975753930281690942784321252339035906196846340713237510382364557685379543498765074448825799342194332681181129770046075018122033421983227887719610112028230603166527303021036386350781414447347150383783816869784006598225583375458609586450854602862569022571672049158809874763812834044257419199631217527367046624888837755311215081173386523806086783266198390289097231168172692326653657393522561741947951887577156666663584249108899327053951891486355179939770150550995812478327735917006194574412518819299303783243886962455399783601229227718787081785391010424030509937403600351414176138124705168002288620664809270046124c2 = 7395591129228876649030819616685821899204832684995757724924450812977470787822266387122334722132760470911599176362617225218345404468270014548817267727669872896838106451520392806497466576907063295603746660003188440170919490157250829308173310715318925771643105064882620746171266499859049038016902162599261409050907140823352990750298239508355767238575709803167676810456559665476121149766947851911064706646506705397091626648713684511780456955453552020460909638016134124590438425738826828694773960514221910109473941451471431637903182205738738109429736425025621308300895473186381826756650667842656050416299166317372707709596assert(gmpy2.gcd(e1, (p-1)*(q1-1)) == 14)assert(gmpy2.gcd(e2, (p-1)*(q2-1)) == 14)e1 = e1 / 14e2 = e2 / 14n1 = p * q1n2 = p * q2phi1 = (p - 1) * (q1 - 1)phi2 = (p - 1) * (q2 - 1)d1 = gmpy2.invert(e1, phi1)d2 = gmpy2.invert(e2, phi2)f1 = pow(c1, d1, n1)f2 = pow(c2, d2, n2)def GCRT(mi, ai): # mi,ai分别表示模数和取模后的值,都为列表结构 assert (isinstance(mi, list) and isinstance(ai, list)) curm, cura = mi[0], ai[0] for (m, a) in zip(mi[1:], ai[1:]): d = gmpy2.gcd(curm, m) c = a - cura assert (c % d == 0) #不成立则不存在解 K = c // d * gmpy2.invert(curm // d, m // d) cura += curm * K curm = curm * m // d cura %= curm return (cura % curm, curm) #(解,最小公倍数)f3, lcm = GCRT([n1, n2], [f1, f2])assert(f3 % n1 == f1)assert(f3 % n2 == f2)assert(lcm == p*q1*q2)n3 = q1*q2c3 = f3 % n3phi3=(q1-1)*(q2-1)assert(gmpy2.gcd(7,phi3)==1)d3=gmpy2.invert(7,phi3)m3=pow(c3,d3,n3)if gmpy2.iroot(m3,2)[1] == 1: flag=gmpy2.iroot(m3,2)[0] print binascii.unhexlify(hex(flag)[2:]) 解密后的wav文件是一个念flag的视频，Flag：cybrics{blum_blum_crypto} De1CTF2019 Babylfsrlfsr是一个线性移位反馈寄存器 https://ctf-wiki.github.io/ctf-wiki/crypto/streamcipher/fsr/lfsr-zh/output的长度是504，根据B-M算法可知，在知道长度为2n的序列之后可以恢复出初始化种子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import hashlibdef pad(x): pad_length = 8 - len(x) return '0'*pad_length+xrr = '001010010111101000001101101111010000001111011001101111011000100001100011111000010001100101110110011000001100111010111110000000111011000110111110001110111000010100110010011111100011010111101101101001110000010111011110010110010011101101010010100101011111011001111010000000001011000011000100000101111010001100000011010011010111001010010101101000110011001110111010000011010101111011110100011110011010000001100100101000010110100100100011001000101010001100000010000100111001110110101000000101011100000001100010'for pad_bit in range(2**8): r = rr+pad(bin(pad_bit)[2:]) index = 0 a = [0]*512 for i in r: if i=='1': a[index]=1 index += 1 res = [] for i in range(256): for j in range(256): if a[i+j]==1: res.append(1) else: res.append(0) sn = [] for i in range(256): if a[256+i]==1: sn.append(1) else: sn.append(0) MS = MatrixSpace(GF(2),256,256) MSS = MatrixSpace(GF(2),1,256) A = MS(res) s = MSS(sn) try: inv = A.inverse() except ZeroDivisionError as e: continue mask = s*inv cm = [] for i in range(255): cm.append(0) cm.append(mask[0][0]) index = 0 for i in range(255): for j in range(256): if j==index: cm.append(1) else: if j==255: cm.append(mask[0][1+i]) else: cm.append(0) index +=1 c = MS(cm) try: c_inv = c.inverse() except ZeroDivisionError as e: continue res = '' for i in range(256): t = a[:256] t = MSS(t) r = (t*c_inv)[0][0] a.insert(0,r) res = str(r) + res FLAG ="de1ctf&#123;"+hashlib.sha256(hex(int(res,2))[2:].rstrip('L')).hexdigest()+"&#125;" if FLAG[7:11]=='1224': print FLAG de1ctf{1224473d5e349dbf2946353444d727d8fa91da3275ed3ac0dedeb7e6a9ad8619} De1CTF2019 Re_sign中关村CTF dp1234e=65537n=9637571466652899741848142654451413405801976834328667418509217149503238513830870985353918314633160277580591819016181785300521866901536670666234046521697590230079161867282389124998093526637796571100147052430445089605759722456767679930869250538932528092292071024877213105462554819256136145385237821098127348787416199401770954567019811050508888349297579329222552491826770225583983899834347983888473219771888063393354348613119521862989609112706536794212028369088219375364362615622092005578099889045473175051574207130932430162265994221914833343534531743589037146933738549770365029230545884239551015472122598634133661853901dp=81339405704902517676022188908547543689627829453799865550091494842725439570571310071337729038516525539158092247771184675844795891671744082925462138427070614848951224652874430072917346702280925974595608822751382808802457160317381440319175601623719969138918927272712366710634393379149593082774688540571485214097c=5971372776574706905158546698157178098706187597204981662036310534369575915776950962893790809274833462545672702278129839887482283641996814437707885716134279091994238891294614019371247451378504745748882207694219990495603397913371579808848136183106703158532870472345648247817132700604598385677497138485776569096958910782582696229046024695529762572289705021673895852985396416704278321332667281973074372362761992335826576550161390158761314769544548809326036026461123102509831887999493584436939086255411387879202594399181211724444617225689922628790388129032022982596393215038044861544602046137258904612792518629229736324827 已知n, e, dp 求 m的题exp12345678910111213import binascii,gmpy2e=65537n=9637571466652899741848142654451413405801976834328667418509217149503238513830870985353918314633160277580591819016181785300521866901536670666234046521697590230079161867282389124998093526637796571100147052430445089605759722456767679930869250538932528092292071024877213105462554819256136145385237821098127348787416199401770954567019811050508888349297579329222552491826770225583983899834347983888473219771888063393354348613119521862989609112706536794212028369088219375364362615622092005578099889045473175051574207130932430162265994221914833343534531743589037146933738549770365029230545884239551015472122598634133661853901dp=81339405704902517676022188908547543689627829453799865550091494842725439570571310071337729038516525539158092247771184675844795891671744082925462138427070614848951224652874430072917346702280925974595608822751382808802457160317381440319175601623719969138918927272712366710634393379149593082774688540571485214097c=5971372776574706905158546698157178098706187597204981662036310534369575915776950962893790809274833462545672702278129839887482283641996814437707885716134279091994238891294614019371247451378504745748882207694219990495603397913371579808848136183106703158532870472345648247817132700604598385677497138485776569096958910782582696229046024695529762572289705021673895852985396416704278321332667281973074372362761992335826576550161390158761314769544548809326036026461123102509831887999493584436939086255411387879202594399181211724444617225689922628790388129032022982596393215038044861544602046137258904612792518629229736324827r = 3s = (pow(r, e*dp, n) - r) % np = gmpy2.gcd(s,n)assert(n % p == 0)q = n / pphi = (p-1)*(q-1)d = gmpy2.invert(e,phi)%phiprint binascii.unhexlify(hex(pow(c,d,n))[2:])]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HSCTF_2019]]></title>
    <url>%2F2019%2F07%2F03%2FHSCTF-2019%2F</url>
    <content type="text"><![CDATA[写在前面几个周之前做的题了，好久没写WP, 题目网站都关了，这几天想起开总结一下，做完题还是要立即写WP，要不然很浪费时间… BiteCode是一道Java的逆向题目，正常使用工具逆向不出来，应该是对文件进行了改动。使用Krakatau进行反编译，要新建一个java/lang/System类，内容没有关系，但是要有，正常下载的Krakatau有些地方需要更改python decompile.py -o temp -p BiteCode BiteCode也可以直接使用 http://www.javadecompilers.com/ 这个在线的工具123456a = [189074585, -227215135, 19240899, 245881291, 233391094, 56978353, -213838484, -231671677, -132473862, 143449065, 108102484, 71123188, 146096006, -173487738, -116507045, -68013365, 171414622, 94412444, 197453081, -50622153, 190140381, 77383944, -41590082, 61204303, -24637751, 61697107, 267894989, -13480562]b = [189074673, -227215214, 19240864, 245881279, 233390992, 56978378, -213838565, -231671605, -132473910, 143449053, 108102411, 71123073, 146096089, -173487628, -116507132, -68013319, 171414529, 94412524, 197453163, -50622201, 190140290, 77383996, -41590047, 61204283, -24637791, 61697122, 267895017, -13480461]flag = &apos;&apos;for i in range(len(a)): flag = flag + chr(a[i] ^ b[i])print flag Flaghsctf{wH04_u_r_2_pr0_4_th1$} DaHeck直接阅读源码逆算法12345678910111213141516public class wp&#123; public static void main(String []args) &#123; String s = new String(&quot;\uffc8\uffbd\uffce\uffbc\uffca\uffb7\uffc5\uffcb\u0005\uffc5\uffd5\uffc1\uffff\uffc1\uffd8\uffd1\uffc4\uffcb\u0010\uffd3\uffc4\u0001\uffbf\uffbf\uffd1\uffc0\uffc5\uffbb\uffd5\uffbe\u0003\uffca\uffff\uffda\uffc3\u0007\uffc2\u0001\uffd4\uffc0\u0004\uffbe\uffff\uffbe\uffc1\ufffd\uffb5&quot;); char[] dst = s.toCharArray(); char[] heck = &quot;001002939948347799120432047441372907443274204020958757273&quot;.toCharArray(); char[] src = new char[dst.length]; for(int i=0; i&lt;dst.length; i++) &#123; src[i] = (char)(heck[i] - dst[i]); &#125; System.out.println(src); &#125;&#125; Flaghsctf{th4t_w4s_fun!_l3ts_try_s0m3_m0r3_r3v3rs3} Forgot Your Password?这道题需要推测数组s的值，已知第7，8次next()函数后得到的值是”hsctfissocoolwow“，使用z3求解器可以求解得到s的值。12345678910111213141516171819202122232425262728293031323334from z3 import *solver = Solver()flag1 = int(('ssiftcsh').encode('hex'), 16)flag2 = int(('wowlooco').encode('hex'), 16)s = [BitVec('s%i' % i, 128) for i in range(2)]def o(x,k): return x&lt;&lt;kdef m(a): return a&amp;0xffffffffffffffffdef next(): b = m(s[0]+s[1]) h() return m(b)def p(k, x): return x&gt;&gt;(64-k)def x(b, a): return a^bdef oro(a, b): return a|bdef h(): s1 = m(x(s[0],s[1])) s[0] = m(x(oro(o(s[0],55),p(55,s[0])),x(s1,(o(s1,14))))) s[1] = m(oro(o(s1,36),p(36,s1)))for j in range(6): next()solver.add(next() == flag1)solver.add(next() == flag2)print solver.check()print solver.model() 求解得到s = [81081519719372872192, 16423178736247365899]代入generator.py得到1234Thanks! Your numbers are: e06f76cd556604f0f21c34f1519d2fd273c8535ab0f954b5ad1cbab7abc18309hsctfissocoolwow Flage06f76cd556604f0f21c34f1519d2fd2 73c8535ab0f954b5ad1cbab7abc18309 trig_is_really_hard阅读源码直接对算法求逆123456789101112131415161718192021222324t = 0for i in range(2, 14): t = t + iprint(t)ans = [-25, 1, 10, 7, 4, 7, 2, 9, 3, 8, 1, 10, 3, -1, -8, 3, -6, 5, -4, 7, -5, 8, -3, 10, -1, 12, 10, 7, -6, 9, -4, 11, -2, 13, -2, -11, 6, -9, 8, -7, 10, -5, 12, 1, -12, 7, -10, 9, -8, 11, -6, 13, -4, 11, 6, -13, 8, -11, 10, -9, 12, -7, 14, -5, 22, -16, 7, -14, 9, -12, 11, -10, 13, -8, 15, -6, -2, 2, -21, 4, -19, 6, -17, 8, -15, 10, -13, 12, -11, 5]print(len(ans))count = 0flag = &apos;&apos;for i in range(1, 13): total = 0 for j in range(i+1): total = total + ans[count + j] - i*pow(-1, i + ans[count+j]) count = count + i + 1 flag = flag + chr(int(total - (13 - i) * pow(-1, total + 13 - i) + 96))print(flag) Flaghsctf{:hyperthonk:} Tux Talk Show 2019是一个猜数的问题，但是因为限制范围很小，所以可以直接使用循环猜同一个数的方式来爆破。123456789101112from pwn import remotewhile True: p =remote(&apos;rev.hsctf.com&apos;,6767) p.recvuntil(&quot;Enter your lucky number: &quot;) p.sendline(&apos;234874835&apos;) try: recv = p.recv() print recv break except: p.close() 看到一个WP可以根据使用相同的libc版本来直接得到这个数，感觉有点神奇，记录一下12345678910111213from pwn import *import ctypesLIBC = ctypes.cdll.LoadLibrary(&apos;/lib/x86_64-linux-gnu/libc-2.27.so&apos;)LIBC.srand(LIBC.time(0))sh = remote(&apos;rev.hsctf.com&apos;, 6767)number = sum([121, 1231231, 20312312, 122342342, 90988878, -30])for i in range(6): number -= LIBC.rand() % 10 -1print numbersh.interactive() Paint直接异或可解，可以使用下面这个网站求解https://gchq.github.io/CyberChef/#recipe=From_Hex(&#39;Auto&#39;)XOR_Brute_Force(1,100,0,&#39;Standard&#39;,false,true,false,&#39;ftc&#39;)Reverse(&#39;Character&#39;)&amp;input=NDM1QjUyNTc1NjQ5NjE1RjYxNTA1NzYxNEQ0OTUxNUE1MDU3NDk2MTUwNUI1QjRENjE0QTUwNUI0ODVGNTY0NTU4NEE1RDRENTYzRQo Flaghsctf{havent_seen_windows_in_a_while} License123456789101112131415161718192021222324252627from pwn import *import stringcontext.log_level=&apos;error&apos;char_set = string.letters+string.digits+&apos;_&apos;flag = &apos;hsctf&#123;&apos;real = &apos;4-EZF2M-7O5F4-V9P7O-EVFDP-E4VDO-O&apos;.replace(&apos;-&apos;,&apos;&apos;)l = len(flag)def check(real, out): return out in realdef try_input(flag): sh = process(&apos;./license&apos;) sh.sendlineafter(&apos;: &apos;, flag) out = sh.recvall().strip().split(&apos;\n&apos;)[-1].replace(&apos;-&apos;,&apos;&apos;) sh.close() return check(real, out)while l &lt;= len(real): for c in char_set: if try_input(flag+c): l += 1 flag += c break print flag Flaghsctf{k3ith_m4k3s_tr4sh_r3}]]></content>
      <categories>
        <category>WriteUp</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java项目管理工具--gradle]]></title>
    <url>%2F2019%2F07%2F02%2Fgradle%2F</url>
    <content type="text"><![CDATA[在IDEA中创建gradle项目的目录结构src/main/java 放置正式代码目录src/main/resources 放置正式配置文件目录src/test/java 放置单元测试代码目录src/test/resources 放置测试配置文件目录src/main/webapp 放置页面元素：js, css, img,jsp.html… groovy语法的简单介绍123456789101112131415161718192021222324252627282930313233343536373839println(&quot;hello groovy&quot;);//groovy可以省略末尾的分号，也可以省略括号println &quot;hello, groovy&quot;//定义变量,def--&gt;弱类型def i = &quot;xiaoming&quot;println i//复杂类型的定义def list = [&apos;a&apos;, &apos;b&apos;]list &lt;&lt; &apos;c&apos;// 取出list中第三个元素println list.get(2)def map = [&apos;key1&apos;:&apos;value1&apos;, &apos;key2&apos;:&apos;value2&apos;]map.key3 = &apos;value3&apos;println map.get(&apos;key3&apos;)//groovy中的闭包//闭包就是一段代码，在gradle中我们把闭包当作参数来使用def b1 = &#123; println &quot;hello b1&quot;&#125;//定义一个方法，方法里面需要包含闭包类型的参数def method1(Closure closure)&#123; closure()&#125;//调用方法method1，参数是闭包b1method1(b1)//定义一个带有参数的闭包def b2 = &#123; v -&gt; println &quot;hello $&#123;v&#125;&quot;&#125;def method2(Closure closure)&#123; closure(&quot;xiaoma&quot;) // 调用的闭包中有参数&#125;method2(b2) gradle简单使用12345678910111213141516171819202122232425262728group &apos;com.itheima&apos;version &apos;1.0-SNAPSHOT&apos;apply plugin: &apos;java&apos;sourceCompatibility = 1.8/**指定所使用的仓库，mavenCentral()表示中央仓库，此刻项目中需要的jar包都会默认从中央仓库中下载到本地指定目录*mavenLocal()*mavenCentral()*以上配置先从本地仓库寻找依赖，如果没有再从中央仓库中下载**/repositories&#123; mavenLocal() mavenCentral()&#125;/***gradle工程所有jar包的坐标都在dependencies属性内放置*每一个jar包的坐标都有三个基本元素组成*group, name, version*testCompile表示该jar包在测试的时候起作用，该属性为jar包的作用域*我们在gradle里面添加坐标的时候都要带上jar包的作用域*具体每一个包的内容可以在maven中央仓库:mvnrepository.com中查询**/dependencies&#123; testCompile group:&apos;junit&apos;, name:&apos;junit&apos;, version:&apos;4.12&apos;&#125; =========================1.钱包创建—&gt;钱包生成，转账交易，余额查询2.智能合约通信3.IPFS服务器]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ipfs私有链的搭建]]></title>
    <url>%2F2019%2F06%2F04%2Fipfs%2F</url>
    <content type="text"><![CDATA[前言主要讲述IPFS私有环境的配置，需要使用两个节点。使用两台Windows10主机完成环境搭建 下载IPFS下载符合自己系统要求的IPFS版本https://ipfs.io/ipns/dist.ipfs.io/#go-ipfs 初始化仓库进入IPFS解压目录，执行ipfs init命令：1234567λ ipfs init initializing IPFS node at C:\Users\Administrator\.ipfsgenerating 2048-bit RSA keypair...donepeer identity: QmRJKX2CKgqetH8i1gcTDK3KEDRswn1ETkpd2AWedr4dsTto get started, enter: ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme 生成了一个IPFS节点，ID:QmRJKX2CKgqetH8i1gcTDK3KEDRswn1ETkpd2AWedr4dsT 配置http head为了方便外部访问，需要修改配置文件，使用如下三条指令修改配置信息123ipfs config Addresses.API /ip4/0.0.0.0/tcp/5001ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin &quot;[\&quot;*\&quot;]&quot;ipfs config --json API.HTTPHeaders.Access-Control-Allow-Methods &quot;[\&quot;PUT\&quot;, \&quot;GET\&quot;, \&quot;POST\&quot;]&quot; 生成共享key私有网络需要拥有相同key的节点相连首先安装go执行环境https://golang.google.cn/dl/使用ipfs-swarm-key-gen创建私有网络共享的key, 私有网络的所有的节点都使用这个key, 不使用这个key的节点无法加入这个私有网络12λ go get -u github.com/Kubuxu/go-ipfs-swarm-key-gen/ipfs-swarm-key-genλ ipfs-swarm-key-gen &gt; C:\Users\EP\.ipfs\swarm.key Attion: 第一个节点需要生成swarm.key后面的节点只需要共享这个key就可以 移除默认的bootstrap节点为了不连接全球IPFS网络，需要将默认的bootstrap节点信息删除1ipfs bootstrap rm -all 加入私有网络如果是第一个节点这个步骤可以忽略如果已知私有网络的一些节点需要把他们做为bootstrap节点添加进新节点1λ ipfs bootstrap add /ip4/IPaddress/tcp/4001/ipfs/QmRJKX2CKgqetH8i1gcTDK3KEDRswn1ETkpd2AWedr4dsT 后面的Hash值就是之前ipfs init时得到的HASH值 结果在第二个节点执行完加入第一个节点的指令后，执行ipfs daemon命令启动两个节点 进入`http://127.0.0.1:5001/webui/ 界面可以查看节点信息可以看到第二个节点已经连接上第一个节点 在第一个节点处上传一个文本文件hello.txt,文件内容是hello,world12λ ipfs add hello.txt 11 B / ? [-----------------------------------------------------------------------------------------------=----------] added QmTnLmP1A3QXFRtAHeXiHJ2fiEhqVGBeUpz4oW6mcFmfDK hello.txt 在第二个节点处使用cat命令得到这个文件：]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>区块链</tag>
        <tag>分布式文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python_notes]]></title>
    <url>%2F2019%2F05%2F01%2Fpython-notes%2F</url>
    <content type="text"><![CDATA[ConfigParserhttps://www.rddoc.com/doc/Python/3.6.0/zh/library/configparser/ Generatorhttps://lotabout.me/2017/Python-Generator/ enumerate()https://blog.csdn.net/churximi/article/details/51648388 format()https://www.runoob.com/python/att-string-format.html collections模块defaultdict()和namedtuple()https://www.cnblogs.com/herbert/p/3468294.html 字符串、整数与16进制相互转换python2:123hex_str = s.encode(&apos;hex&apos;) #字符串转16进制s = hex_str.decode(&apos;hex&apos;) #16进制转字符串s = (hex(num)[2:].replace(&apos;L&apos;,&apos;&apos;)).decode(&apos;hex&apos;) #整数转字符串 python3:123456789hexbytes = &quot;&quot;for d in origin_bytes: hexbytes = hexbytes + (hex(ord(d))[2:]).zfill(2) #字符串转16进制的形式s = bytes.fromhex(hexbytes) #16进制转字符串#another wayimport codecscodecs.encode(bytes(&apos;GHI&apos;, &apos;utf-8&apos;), &apos;hex&apos;) #字符串转16进制codecs.decode(&apos;474849&apos;, &apos;hex&apos;) #16进制转字符串]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[re_sub]]></title>
    <url>%2F2019%2F05%2F01%2Fre-sub%2F</url>
    <content type="text"><![CDATA[re.sub的功能re是regular expression的所写，表示正则表达式sub是substitute的所写，表示替换；re.sub是个正则表达式方面的函数，用来实现通过正则表达式，实现比普通字符串的replace更加强大的替换功能；举个最简单的例子：如果输入字符串是：1inputStr = &quot;hello 111 world 111&quot; 那么你可以通过1replacedStr = inputStr.replace(&quot;111&quot;, &quot;222&quot;) 去换成1&quot;hello 222 world 222&quot; 但是，如果输入字符串是：1inputStr = &quot;hello 123 world 456&quot; 而你是想把123和456，都换成222那么就没法直接通过字符串的replace达到这一目的了。就需要借助于re.sub，通过正则表达式，来实现这种相对复杂的字符串的替换：1replacedStr = re.sub(&quot;\d+&quot;, &quot;222&quot;, inputStr) 当然，实际情况中，会有比这个例子更加复杂的，其他各种特殊情况，就只能通过此re.sub去实现如此复杂的替换的功能了。所以，re.sub的含义，作用，功能就是：对于输入的一个字符串，利用正则表达式（的强大的字符串处理功能），去实现（相对复杂的）字符串替换处理，然后返回被替换后的字符串其中re.sub还支持各种参数，比如count指定要替换的个数等等。 re.sub的各个参数的详细解释re.sub共有五个参数。其中三个必选参数：pattern, repl, string两个可选参数：count, flags 第一个参数：patternpattern: 表示正则中的模式字符串反斜杠加数字（\N），则对应着匹配的组（matched group）比如\6，表示匹配前面pattern中的第6个group意味着，pattern中，前面肯定是存在对应的，第6个group，然后你后面也才能去引用比如，想要处理：1hello crifan, nihao crifan 且此处的，前后的crifan，肯定是一样的。而想要把整个这样的字符串，换成crifanli则就可以这样的re.sub实现替换：123inputStr = &quot;hello crifan, nihao crifan&quot;;replacedStr = re.sub(r&quot;hello (\w+), nihao \1&quot;, &quot;crifanli&quot;, inputStr);print &quot;replacedStr=&quot;,replacedStr; #crifanli 第二个参数：replrepl可以是字符串，也可以是函数。repl是字符串如果repl是字符串的话，其中的任何反斜杠转义字符，都会被处理的\n：会被处理为对应的换行符；\r：会被处理为回车符；其他不能识别的转移字符，则只是被识别为普通的字符：比如\j，会被处理为j这个字母本身；反斜杠加g以及中括号内一个名字，即：\g&lt;name&gt;，对应着命了名的组，named group接着上面的举例：想要把对应的：1hello crifan, nihao crifan 中的crifan提取出来，只剩：crifan就可以写成：123inputStr = "hello crifan, nihao crifan";replacedStr = re.sub(r"hello (\w+), nihao \1", "\g&lt;1&gt;", inputStr);print "replacedStr=",replacedStr; #crifan 对应的带命名的组（named group）的版本是：123inputStr = "hello crifan, nihao crifan";replacedStr = re.sub(r"hello (?P&lt;name&gt;\w+), nihao (?P=name)", "\g&lt;name&gt;", inputStr);print "replacedStr=",replacedStr; #crifan repl是函数举例说明：比如输入内容是：1hello 123 world 456 想要把其中的数字部分，都加上111，变成：1hello 234 world 567 那么就可以写成：123456789101112131415161718192021222324252627282930#!/usr/bin/python# -*- coding: utf-8 -*-import re; def pythonReSubDemo(): """ demo Pyton re.sub """ inputStr = "hello 123 world 456"; def _add111(matched): intStr = matched.group("number"); #123 intValue = int(intStr); addedValue = intValue + 111; #234 addedValueStr = str(addedValue); return addedValueStr; replacedStr = re.sub("(?P&lt;number&gt;\d+)", _add111, inputStr); print "replacedStr=",replacedStr; #hello 234 world 567 ###############################################################################if __name__=="__main__": pythonReSubDemo();``` ### 第三个参数：stringstring，即表示要被处理，要被替换的那个string字符串。### 第四个参数：count举例说明,比如对于： hello 123 world 456 nihao 7891234567891011121314151617181920212223242526只是像要处理前面两个数字：123,456，分别给他们加111，而不处理789 那么就可以写成： ```Python#!/usr/bin/python# -*- coding: utf-8 -*-import re; def pythonReSubDemo(): &quot;&quot;&quot; demo Pyton re.sub &quot;&quot;&quot; inputStr = &quot;hello 123 world 456 nihao 789&quot;; def _add111(matched): intStr = matched.group(&quot;number&quot;); #123 intValue = int(intStr); addedValue = intValue + 111; #234 addedValueStr = str(addedValue); return addedValueStr; replacedStr = re.sub(&quot;(?P&lt;number&gt;\d+)&quot;, _add111, inputStr, 2); print &quot;replacedStr=&quot;,replacedStr; #hello 234 world 567 nihao 789 ###############################################################################if __name__==&quot;__main__&quot;: pythonReSubDemo(); 关于re.sub的注意事项要注意，被替换的字符串，即参数repl，是普通的字符串，不是pattern注意到，语法是：1re.sub(pattern, repl, string, count=0, flags=0) 即，对应的第二个参数是repl。需要你指定对应的r前缀，才是pattern：1r&quot;xxxx&quot; 不要误把第四个参数flag的值，传递到第三个参数count中了当传递第三个参数，原以为是flag的值是，结果实际上是count的值所以导致re.sub不功能，所以要参数指定清楚了：1replacedStr = re.sub(replacePattern, orignialStr, replacedPartStr, flags=re.I); # can omit count parameter 或：1replacedStr = re.sub(replacePattern, orignialStr, replacedPartStr, 1, re.I); # must designate count parameter 才可以正常工作。 转载：https://www.crifan.com/python_re_sub_detailed_introduction/]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu]]></title>
    <url>%2F2019%2F04%2F27%2Fubuntu%2F</url>
    <content type="text"><![CDATA[vim配置Vim配置 vi中Linux虚拟机与windows主机之间相互复制vim有12个粘贴板，分别是0、1、2、…、9、a、“、＋；用:reg命令可以查看各个粘贴板里的内容。在vim中简单用y只是复制到“（双引号)粘贴板里，同样用p粘贴的也是这个粘贴板里的内容要将vim的内容复制到某个粘贴板，需要退出编辑模式，进入正常模式后，选择要复制的内容，然后按”Ny完成复制，其中N为粘贴板号(注意是按一下双引号然后按粘贴板号最后按y)，例如要把内容复制到粘贴板a，选中内容后按”ay就可以了，有两点需要说明一下“号粘贴板（临时粘贴板）比较特殊，直接按y就复制到这个粘贴板中了，直接按p就粘贴这个粘贴板中的内容+号粘贴板是系统粘贴板，用”+y将内容复制到该粘贴板后可以使用Ctrl＋V将其粘贴到其他文档中，同理，要把在其他地方用Ctrl＋C或右键复制的内容复制到vim中，需要在正常模式下按”+p要将vim某个粘贴板里的内容粘贴进来，需要退出编辑模式，在正常模式按”Np，其中N为粘贴板号，如上所述，可以按”5p将5号粘贴板里的内容粘贴进来，也可以按”+p将系统全局粘贴板里的内容粘贴进来。注意：在我这里，只有vim.gtk或vim.gnome才能使用系统全局粘贴板，默认的vim.basic看不到+号寄存器根据平台不同，要分两种情况。先用下面命令确定你属于哪一种1vim --version | grep clipboard 情况一，如果结果里你找到加号开头的+clipboard, vim没问题.用”+y 代替y将选中的内容复制到系统剪贴板，效果和ctrl-c一致。 用”+p代替p将剪贴板内容复制到指定位置，也可以用ctrl-v。 d，x，c，s也一样，用之前前面加”+。 如果想偷懒用y直接把内容复制到系统剪贴板，需要到vim配置文件.vimrc里加一行属性。用下面命令开始配置1vim ~/.vimrc 然后，加入下面这行1set clipboard=unnamed 现在你的y，d，x，p已经能和 ctrl-c和ctrl-v 一个效果，并且能互相混用。情况二，如果找到的是负号开头的-clipboard，说明你的vim不支持系统剪切板，我的MacOS系统自带vim就不支持。需要先重新安装vim，Linux系统1sudo apt install vim-gtk 或者是 sudo apt-get install vim-gnome MacOS1brew install vim 安装好之后，重复情况一的操作即可。 vi 常用命令12345678910111213141516171819202122232425262728293031复制： 复制一行则：yy 复制三行则：3yy，即从当前光标+下两行。 复制当前光标所在的位置到行尾：y$ 复制当前光标所在的位置到行首：y^剪切： 剪切一行：dd 前切三行：3dd,即从当前行+下两行被剪切了。 剪切当前行光标所在的位置到行尾：d$ 剪切当前行光标所在的位置到行首：d^粘贴： 用v选中文本之后可以按y进行复制，如果按d就表示剪切，之后按p进行粘贴。撤销与恢复： &apos;u&apos; : 撤销上一个编辑操作 &apos;ctrl + r&apos; : 恢复，即回退前一个命令 &apos;U&apos; : 行撤销，撤销所有在前一个编辑行上的操作vi 编辑器中跳到文件的第一行：键盘按下 小写 ggvi 编辑器跳到文件最后一行：键盘按 shift + g按行快速移动光标使用键盘上的编辑键Home，快速将光标移动至当前行的行首。除此之外，也可以在命令模式中使用快捷键&quot;^&quot;（即Shift+6）或0（数字0）。快速移动光标至当前行的行尾编辑键End。也可以在命令模式中使用快捷键&quot;$&quot;（Shift+4）。与快捷键&quot;^&quot;和0不同，快捷键&quot;$&quot;前可以加上数字表示移动的行数。例如使用&quot;1$&quot;表示当前行的行尾，&quot;2$&quot;表示当前行的下一行的行尾。 NERDTree插件https://www.jianshu.com/p/eXMxGx 打开文件夹123nautilus，直接打开Home。 nautilus . 打开当前文件夹 nautilus /var/www/aaa/ 打开此文件夹。 Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?12ps aux | grep -i aptsudo kill -9 &lt;process id&gt; another easier way1sudo killall apt apt-get ln指令ln [参数][源文件或目录][目标文件或目录]Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。软链接(-s选项)：1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式2.软链接可以 跨文件系统 ，硬链接不可以3.软链接可以对一个不存在的文件名进行链接4.软链接可以对目录进行链接硬链接(无选项):1.硬链接，以文件副本的形式存在。但不占用实际空间2.不允许给目录创建硬链接3.硬链接只有在同一个文件系统中才能创建]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TEETHER:Gnawing at ethereum to Automatically Exploit Smart Contracts]]></title>
    <url>%2F2018%2F12%2F19%2Fteether%2F</url>
    <content type="text"><![CDATA[摘要针对智能合约实现自动化漏洞识别和注入。为有漏洞的合约生成通用定义，在字节码的基础上使用TEETHER实现注入。 介绍这个工具主要用来实现自动化漏洞注入，假设攻击者无任何特权。对合约漏洞进行定义，合约中价值的转移只在少数情况下发生。为此定义了四种标准：可以用来创建常规交易的(CALL)，用来结束合约的(SELFDESTRUCT)，两个可以引起代码注入的(CALLCODE, DELEGATECALL)我们提出了一种方法来找到一个合约中的漏洞执行路径，并且使用符号执行来自动化生成一个注入。方法如下: 我们在合约的控制流图中寻找关键路径，然后确定参数可以被攻击者控制的关键指令。一旦确定了一条路径，我们利用符号执行将这条路径转化成一系列的约束条件。使用约束条件求解器我们就可以推断攻击者必须执行哪些事务来触发漏洞。智能合约的特定执行环境使这个任务并不简单。值得注意的是，我们展示了如何符号化地处理哈希值，这些哈希值在智能合约中被广泛使用。为了评估我们方法的实用性，我们对区块链上38757个合约进行了大规模分析。TEETHER发现了815个合约可以被自动化注入，不需要人工交互和确定，并且不需要合约的源代码。因为代码共享，这使1731个账户处于危险之中。更进一步，示例表明，许多这些潜在的漏洞是由于Solidity的设计机制和对EVM执行模式的误解导致的。主要贡献:1.在低级的EVM指令上，提出了一个漏洞合约的广泛定义。2.基于智能合约字节码提出了一个端到端的自动化注入工具。最后我们还处理了一些EVM的特定挑战，比如说符号化地处理哈希值的新方法。3.使用这个工具对智能合约进行了大规模的分析。 背景在这部分介绍智能合约，以太坊虚拟机和智能合约的执行模式。 交易系统用户在转账和调用合约的时候发起交易，矿工处理交易并且使用共识协议确认新出的块。矿工挖块会获得处理费，为了防止拒绝服务攻击和鼓励矿工出块。区块链上的每个节点都可以验证目前的系统状态。 智能合约智能合约是与特定代码片段相关的以太坊账户，每个智能合约都有私有存储，虽然私有存储空间的内容只有合约本身可以读写，但是通过分析区块链上每一笔交易依然可以重构合约私有存储中的内容。 EVMEVM是一个256比特的堆栈虚拟机。除了算术指令和控制流指令，EVM还提供特定指令来获取当前交易的访问字段、更改合约的私有存储、查询当前区块链状态和创建下一笔交易。 Smart Contract Vulnerabilities分析方法：静态地分析契约的代码，以揭示可能被滥用来窃取契约中存储的Ether的关键代码部分。 Critical Instructions确定了四条EVM指令，如果想从合约中提取Ether必须执行其中的一种。这四条指令可以分为两类：有两条指令可以直接转账，另外两条允许在合约上下文中执行任意Ethereum字节码。 Direct value transferCALL和SELFDESTRUCT可以允许直接转账到一个指定的地址，CALL指令执行的时候会栈中会有如下参数： gas—在交易期间可能消耗的gas to—交易的收款方 value—转账金额4-7. in offset, in size, out offset, out size—内存位置和调用数据长度分别返回数据 ///如果攻击者可以控制第二个栈内参数并且第三个参数非零，那么就可以达到攻击的目的。SELFDESTRUCT指令可以在销毁合约的同时将合约的余额转到指定的地址。Code injectionCALLCoDE和DELEGATECALL指令会导致在合约上下文中执行第三方代码。如果攻击者可以控制CALLCODE或者DELEGATECALL指令的to，那么就可以在合约中执行to合约中的第三方代码。Vulnerable State定义合约的危险状态：Def1(Critical Path): CALL指令执行时，第三个栈参数非零并且第二个栈参数可以被控制。 SELFDESTRUCT指令执行的时候第一个栈参数可以被控制。 CALLCODE或者DELEGATECALL指令执行的时候第二个栈参数可以被控制。Def2(Vulnerable State):如果某个交易可以执行Critical Path那么就是Vulnarable StateStorage参考以下合约：12345678910111213contract Stateful&#123; bool vulnerabel = false; function makeVulnerable() &#123; vulnerable = true; &#125; function exploit(address attacker) &#123; require(vulnerabel); attacker.transfer(this.balance); &#125;&#125; 当vulnerable变量等于false的时候直接调用exploit函数并不能攻击成功，但是在调用makeVulnerable函数后就会到达vulnerable状态。所以我们必须扩展我们的定义，以包含状态的概念，它捕获对合约存储所做的修改。唯一能够更改存储的指令就是SSTORE，定义state-changing transactionsDef3(State Changing Path)至少包含一条SSTORE指令Def4(State Changing Transaction)如果一个交易的执行路径是一个State Changing Path将上述与Def2结合可以给出以下定义：Def5(Vulnerable)如果一个合约中存在一系列能够导致vulnerabel state的state changing transaction一个成功的auto exploit是由一系列导致状态更改的关键交易组成。 Automatic Exploitation第一步，CFG发现模型反编译EVM字节码然后重构控制流图(CFG).然后扫描控制流图获取critical instruction和state changing instruction。Path generation模型从CFG的根部获取达到这些指令的路径，constraint generation模型使用符号执行生成一系列的路径约束。最后exploit generation模型解决critical path和state changing path约束来生成exploit。 CFG RecoveryEVM使用不直接的跳转提供控制流指令，有条件的JUMPI和无条件的JUMP都从栈顶读取跳转目的地。跳转目的地在某些情况下可以轻松得到，比如说PUSH2 &lt;addr&gt;;JUMP，但是在某些情况下也不那么明显。]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JarvisOJ_软件破解(1)]]></title>
    <url>%2F2018%2F12%2F18%2Fjarvis-wp4%2F</url>
    <content type="text"><![CDATA[下载文件下载文件后解压，得到一个可执行文件，用PEiD分析，发现软件没有加壳，而且是32位的可执行文件。 用Ollydbg分析将文件在od中打开，查看引用的所有字符串：发现了图中”你赢了”字样的字符串，猜想判断语句应该在其附近。转到该位置:在其周围发现一系列的判断和跳转语句，猜想应该与字符串判断相关:在上面”输入口令”字样处下断点: 动态调试运行下断点后进行动态调试运行，发现程序在输入字符串后确实停留在断点位置，step over：根据调试信息和汇编语句可以判断出程序的执行逻辑:图中红色大方框中是循环判断字符串的汇编代码，其逻辑是: 取EAX与ECX相加后得到地址中的值赋予DL 将DL与EAX地址中的字符串亦或(EAX中的字符串就是输入的字符串)EAX与ECX的地址相加为0x00CD77F8，其中具体值如红色长方框中所示。在异或完成后将结果与46171C1B, 3020FDF4, 7E8E0CB7, 78, DE进行比较，只有值全部相等时才认为正确。编写程序解码注意最后比较的数字中有高低位的区别123456s1 = [0x28, 0x57, 0x64, 0x6B, 0x93, 0x8F, 0x65, 0x51, 0xE3, 0x53, 0xE4, 0x4E, 0x1A, 0xFF]s2 = [0x1B, 0x1C, 0x17, 0x46, 0xF4, 0xFD, 0x20, 0x30, 0xB7, 0x0C, 0x8E, 0x7E, 0x78, 0xDE]flag = ''for i in range(len(s1)): flag = flag + chr(s2[i] ^ s1[i])print flag 运行后得到的flag为：3Ks-grEaT_j0b!]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JarvisOJ_stheasy]]></title>
    <url>%2F2018%2F12%2F17%2Fjarvis-wp3%2F</url>
    <content type="text"><![CDATA[使用file指令查看文件属性1234$file ctf2ctf2: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.18, BuildID[sha1]=ae99a50022c1d9d3bf96c045151d1edcdab9af94, stripped 在linux下尝试运行123$ ./ctf2Input flag:jdijifFlag is wrong. 在IDA32下打开main函数的伪代码:红色方框中是进行匹配的函数名称sub_8048530()函数伪代码:所求的flag与数组byte_8049B15和字符串byte_8049AE0有关，它们具体的值如下：红色方框为字符串，蓝色方框为数组的值 可以根据下列代码解出flag123456789num = [0x48, 0x5D, 0x8D, 0x24, 0x84, 0x27, 0x99, 0x9F, 0x54, 0x18, \ 0x1E, 0x69, 0x7E, 0x33, 0x15, 0x72, 0x8D, 0x33, 0x24, 0x63, 0x21, \ 0x54, 0x0C, 0x78, 0x78, 0x78, 0x78, 0x78, 0x1B, 0x0]s = 'ak2j9Gh&#125;AgfY4ds-a6QW1#k5ER_T[cvLbV7nOm3ZeX&#123;CMt8SZo]U'f = ''print len(s)for i in range(29): f = f + s[num[i] / 3 - 2]print f 运行出来flag的值为:kctf{YoU_hAVe-GOt-fLg_233333}]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JarvisOJ_FindKey]]></title>
    <url>%2F2018%2F12%2F17%2Fjarvis-wp2%2F</url>
    <content type="text"><![CDATA[下载文件使用file指令查看文件类型:12$file findkeyfindkey.pyo: python 2.7 byte-compiled 发现文件是python2的字节码文件 使用python运行findkey字节码123$ python findkey.pyoInput your Key:hhhWrong Key!! 使用uncompyle6工具对python字节码反汇编安装：python -m pip install uncompyle6使用: compyle6 findkey获得的反汇编代码:12345678910111213141516171819202122232425# uncompyle6 version 3.2.4# Python bytecode 2.7 (62211)# Decompiled from: Python 2.7.15rc1 (default, Nov 12 2018, 14:31:15) # [GCC 7.3.0]# Embedded file name: findkey# Compiled at: 2016-04-30 02:54:18import syslookup = [196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2, 245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224, 69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73, 148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22, 55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186, 0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113, 79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185, 183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9, 136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208, 207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120, 195, 45, 4, 142, 139]pwda = [188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42]pwdb = [53, 222, 230, 35, 67, 248, 226, 216, 17, 209, 32, 2, 181, 200, 171, 60, 108]flag = raw_input('Input your Key:').strip()if len(flag) != 17: print 'Wrong Key!!' sys.exit(1)flag = flag[::-1]for i in range(0, len(flag)): if ord(flag[i]) + pwda[i] &amp; 255 != lookup[i + pwdb[i]]: print 'Wrong Key!!' sys.exit(1)print 'Congratulations!!'# okay decompiling findkey.pyoFile '-o' doesn't exist. SkippedFile 'test.py' doesn't exist. Skipped# # Successfully decompiled file 使用下列代码获取key123456789import syslookup = [196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2, 245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224, 69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73, 148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22, 55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186, 0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113, 79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185, 183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9, 136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208, 207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120, 195, 45, 4, 142, 139]pwda = [188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42]pwdb = [53, 222, 230, 35, 67, 248, 226, 216, 17, 209, 32, 2, 181, 200, 171, 60, 108]flag = &apos;&apos;for i in range(0, len(pwda)): tmp = lookup[i + pwdb[i]] - pwda[i] &amp; 255 flag = flag + chr(tmp)print flag[::-1] python中s[start: end: step]，所以flag[::-1]表示从字符串结尾到字符串开头逆序]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JarvisOJ_CrackMe]]></title>
    <url>%2F2018%2F12%2F17%2Fjarvis-wp1%2F</url>
    <content type="text"><![CDATA[题目下载后得到exe可执行文件，执行界面如下：FLAG就是注册码，说明需要得到与输入字符串相匹配的正确注册码 使用PEiD工具分析exe文件是否加壳，运行结果如下：说明可执行文件没有被加壳，编程语言是C# 使用.NET Reflector对可执行文件进行分析：注册码使用Base64编码后的结果为:UENURntFYTV5X0RvX05ldF9DcjRjazNyfQ==使用Base64解码后结果为:PCTF{Ea5y_Do_Net_Cr4ck3r}]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PEiD的使用]]></title>
    <url>%2F2018%2F12%2F17%2Fpeid%2F</url>
    <content type="text"><![CDATA[PEiD是一个经典的查壳程序,其插件数量远超百种,使它具备了各种功能,例如通用脱壳和针对性脱壳.虽然已经停止更新,但是特征,签名检测等技术没有失效,你只需要给予其新的特征识别库即可用于新壳的检测. 什么时候需要使用PEiD 快速鉴定一个程序是否正常? 它的入口点是什么? 用什么工具开发的 是否被加了已知壳? 查看它的反汇编代码 PE头结构 脱简易的壳使用图中红色方框中的内容表示文件用什么软件编写的，或者用什么软件加壳。这里表示是用C#编写的。如果是未知软件，点击红色方框可以显示有没有加壳，具体信息需要点击弹出框中的绿色框中的按钮。]]></content>
      <categories>
        <category>逆向_工具</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向笔记]]></title>
    <url>%2F2018%2F12%2F13%2Fre-notes%2F</url>
    <content type="text"><![CDATA[学习网站CTF WikiJarvis OJSUCTF 常规逆向流程1.使用strings/file/binwalk/IDA等静态分析工具收集信息，并根据这些静态信息进行google/github搜索2.研究程序的保护方法，如代码混淆，保护壳及反调试等技术，并设法破除或绕过保护3.反汇编目标软件，快速定位到关键代码进行分析4.结合动态调试，验证自己的初期猜想，在分析的过程中理清程序功能5.针对程序功能，写出对应脚本，求解出 flag CTF逆向中通常出现的加密算法Base64将 3 字节的数据，先后放入一个 24 位的缓冲区中，先来的字节占高位。数据不足 3 字节的话，于缓冲器中剩下的比特用 0 补足。每次取出 6 比特，按照其值选择ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/中的字符作为编码后的输出，直到全部输入数据转换完成。通常而言 Base64 的识别特征为索引表，当我们能找到ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/这样索引表，再经过简单的分析基本就能判定是 Base64 编码。有些题目 base64 的索引表是会变的，一些变种的 base64 主要 就是修改了这个索引表。 Tea(Tiny Encryption Algorithm微型加密算法)是一个简单的分组加密算法，使用Feistel结构进行加密。每次加密64位，密钥长度为128位，推荐迭代次数为64.在 Tea 算法中其最主要的识别特征就是 拥有一个 image number ：0x9e3779b9，有些编程人员为了避免在程序中直接出现”mov 变量，0x9e3779b”，以免被破解者直接搜索0x9e3779b这个常数得知使用TEA算法，所以有时会使用”sub 变量，0x61C88647“代替”mov 变量，0x9e3779b”，0x61C88647=－(0x9e3779b)。最初的Tea算法已经被破解，增加了许多变种形式，比如说XTea,XxTea… RC4流加密算法MD5鲜明标识：1234h0 = 0x67452301;h1 = 0xefcdab89;h2 = 0x98badcfe;h3 = 0x10325476; 虚拟机指令Unicorn引擎Unicorn 是一个轻量级, 多平台, 多架构的 CPU 模拟器框架. 我们可以将其应用于这些情景: 比如我们单纯只是需要模拟代码的执行而非需要一个真的 CPU 去完成那些操作, 又或者想要更安全地分析恶意代码, 检测病毒特征, 或者想要在逆向过程中验证某些代码的含义.一个简单的例子如下：1234567891011121314151617181920212223242526272829303132333435363738from __future__ import print_functionfrom unicorn import *from unicorn.x86_const import *# code to be emulatedX86_CODE32 = b"\x41\x4a" # INC ecx; DEC edx# memory address where emulation startsADDRESS = 0x1000000print("Emulate i386 code")try: # Initialize emulator in X86-32bit mode mu = Uc(UC_ARCH_X86, UC_MODE_32) # map 2MB memory for this emulation mu.mem_map(ADDRESS, 2 * 1024 * 1024) # write machine code to be emulated to memory mu.mem_write(ADDRESS, X86_CODE32) # initialize machine registers mu.reg_write(UC_X86_REG_ECX, 0x1234) mu.reg_write(UC_X86_REG_EDX, 0x7890) # emulate code in infinite time &amp; unlimited instructions mu.emu_start(ADDRESS, ADDRESS + len(X86_CODE32)) # now print out some registers print("Emulation done. Below is the CPU context") r_ecx = mu.reg_read(UC_X86_REG_ECX) r_edx = mu.reg_read(UC_X86_REG_EDX) print("&gt;&gt;&gt; ECX = 0x%x" %r_ecx) print("&gt;&gt;&gt; EDX = 0x%x" %r_edx)except UcError as e: print("ERROR: %s" % e) 更多示例代码 IDA快捷键Shift + F12 字符串查找]]></content>
      <categories>
        <category>逆向_学习笔记</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn学习笔记]]></title>
    <url>%2F2018%2F12%2F13%2Fpwn-note%2F</url>
    <content type="text"><![CDATA[学习网站CTF WikiJarvis OJSUCTFpwnable.twpwnable.kr 查看二进制文件是32位系统还是64位系统1file filename 查看文件用了哪些保护机制12gdb filename(gdb) checksec 各种保护机制的作用Cannary: 栈溢出保护，用来缓解缓冲区溢出攻击，当启用栈保护以后，函数开始执行时会先在栈里面插入cookie信息，当函数真正的返回的时候会验证cookie信息是否合法，如果不合法就停止运行程序Fortify: 也是为了防止缓冲区溢出攻击NX(Windows平台称其为DEP): 不可执行，将数据所在的内页标记为不可执行，如果程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不会执行恶意指令。PIE(ASLR): ASLR:地址随机化。PIE:Position Independent Executables位置独立的可执行区域。 二进制文件中的函数查找1readelf -a libc-2.19.so | grep &quot;system&quot; 二进制文件中的字符串查找1strings -a -t x libc-2.19.so | grep &quot;/bin/sh&quot; pwndbg工具在docker中的使用docker run -it \—rm \-h ${ctf_name} \—name ${ctf_name} \-v $(pwd)/${ctf_name}:/ctf/work \-p 23946:23946 \—cap-add=SYS_PTRACE \skysider/pwndocker docker run -it \—rm \-h ${oyente} \—name ${oyente} \-v $(pwd)/${oyente}:/oyente/oyente \-p 23946:23946 \—cap-add=SYS_PTRACE \luongnguyen/oyente]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu:16.04 docker安装]]></title>
    <url>%2F2018%2F12%2F13%2Fdocker-install%2F</url>
    <content type="text"><![CDATA[卸载旧的版本123sudo apt-get remove docker \ docker-engine \ docker.io 使用APT安装添加使用 HTTPS 传输的软件包以及 CA 证书1234567sudo apt-get updatesudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common 为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥1curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add - 向 source.list 中添加 Docker 软件源1234sudo add-apt-repository \ &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \ $(lsb_release -cs) \ stable&quot; 安装Docker CE12sudo apt-get updatesudo apt-get install -y docker-ce 建立Docker用户组建立Docker组1sudo groupadd docker 当前用户加入Docker组1sudo usermod -aG docker $USER 启动Docker CE12sudo systemctl enable dockersudo systemctl start docker 进行如下测试123456docker run hello-worldUnable to find image &apos;hello-world:latest&apos; locallylatest: Pulling from library/hello-worldca4f61b1923c: Pull complete... 镜像加速配置国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如: Docker 官方提供的中国 registry mirror https://registry.docker-cn.com 七牛云加速器 https://reg-mirror.qiniu.com/ 修改/etc/docker/daemon.json文件sudo gedit /etc/docker/daemon.json添加以下内容：12345&#123; &quot;registry-mirrors&quot;: [ &quot;https://registry.docker-cn.com&quot; ]&#125; 重新启动服务12sudo systemctl daemon-reloadsudo systemctl restart docker Docker: Got permission denied问题描述12345678910docker versionClient: Version: 18.06.1-ce API version: 1.38 Go version: go1.10.4 Git commit: e68fc7a Built: Mon Oct 1 14:25:31 2018 OS/Arch: linux/amd64 Experimental: falseGot permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.38/version: dial unix /var/run/docker.sock: connect: permission denied 解决方案1sudo chmod 666 /var/run/docker.sock Docker: error with docker stop/kill问题描述123$sudo docker kill webserverError response from daemon: Cannot kill container: webserver: Cannot kill container 0e06fdc024071aeb655a04fc12baa51cac09c2b1ab2139d810b27e1cdf4f967e: unknown error after kill: docker-runc did not terminate sucessfully: container_linux.go:393: signaling init process caused &quot;permission denied&quot;: unknown 解决方案Check status: sudo aa-statusShutdown and prevent it from restarting: sudo systemctl disable apparmor.service --nowUnload AppArmor profiles: sudo service apparmor teardownCheck status: sudo aa-statusAppArmor和SELinux都用于Liunx的强制访问控制(MAC)]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZEUS:Analyzing Safety of Smart Contracts]]></title>
    <url>%2F2018%2F12%2F11%2Fzeus%2F</url>
    <content type="text"><![CDATA[摘要一个智能合约无论占有多少资金在部署完成以后很难再修补漏洞。最近一个漏洞导致近五千万美元的加密货币损失。我们设计了验证智能合约正确性和公平性的框架—ZEUS。正确性指符合程序安全规则，公平性指符合高级商业逻辑。ZEUS利用抽象解释和符号执行方法进行检查，并且使用了约束角条款来快速验证合约的安全。我们基于以太坊和超级账本平台构建了ZEUS，并且使用它评估了超过22.4K的合约。我们的评估表明，超过94.6%的合约(持有加密货币价值超过5亿)是有漏洞的。ZEUS有零漏报率和低误报率，并且与现有技术相比研究分析时间上有一个数量级的改进。Constrained Horn Clause(CHC) verfication约束角条款验证 CHC是用来表示程序行为的中间语言，可以用来解释命令式、功能式、并发式的语言，也可以用来解释状态机、交易系统、马尔科夫链等计算模型。成功案例：Windows设备驱动验证现有工具：Z3、QARMC(CEGAR—Counter Example Guided Abstraction Refinement)、TRACER、VeriMAP(specialisation) 介绍区块链是巩固比特币等加密货币的设计模式。它使用共识算法来保证互不信任的节点在无可行第三方的参与下进行可验证交易。它的应用使得智能合约可以使用程序性的编码规则反映任意多方交易。去年区块链投资超过14亿美元，而且自主应用的增加趋势使得智能合约正迅速成为实施金融工具的首选手段(比如说:货币、衍生品、钱包等)还有去中性化的赌博应用。共识机制使得智能合约忠实执行，参与方的特权有：1.验证智能合约的正确性,ie:句法实现满足最佳编程实践;2.验证智能合约的公平性,ie:程序满足高层次的商业交易逻辑.虽然人工审计智能合约的正确性在某种程度上是可能的，但是它容易出错。但另一方面，自动正式审计需要特定的工具和逻辑。而且智能合约不像其他分布式系统代码一样，无论它持有多少金额，它都不可篡改并且难以修补，这使得问题进一步加剧。举例来说，TheDAO的投资者损失了将近5千万美元的加密货币，因为程序漏洞允许攻击者不断虹吸资金。在这篇文章中，我们跟踪了智能合约的正式验证问题，在部署之前验证其正确性和公平性至关重要。1234567891011while (Balance &gt; (depositors[index].Amount * 115/100) &amp;&amp; index &lt; Total_Investors) &#123; if(depositors[index].Amount!=0) &#123; payment = depositors[index].Amount * 115/100; depositors[index].EtherAddress.send(payment); Balance -= payment; Total_Paid_Out += payment; depositors[index].Amount = 0; //remove investor &#125; break;&#125; 上述智能合约向任何投资者提供15%的利润，但是它同时存在正确性和公平性的问题。第一，第六行的算术计算可能发生溢出，这是一个正确性的漏洞；第二，变量index在循环中从来都没有增加过，所以回报仅仅给了一个投资者；最后，break语句在付款给第一个投资者(智能合约部署者)后执行直接终止循环，所以该合约并不偿还任意其他的投资者，后两个漏洞导致了公平性的问题。大多数智能合约领域的现有技术旨在处理安全性和设计时的隐私问题，很少研究智能合约的缺陷.Oyente在字节码层次上使用符号执行来检测漏洞，但他既不兼容也不健全。就像我们观察和与Oyente开发人员沟通过的那样，即使在一些微不足道的合约中也会出现很多误报。因为仅依靠字节码很难恢复作者意图(因为缺少上下文信息:包含类型、不同的函数调用重用相同的字节码等)很多公平性和正确性的问题，包含整数上溢和下溢还有其他的，都被Oyente忽略了。更近一步，它保守地处理循环，导致低估了循环行为，所以会忽略代码1中的两个公平性的漏洞。Bhargavan提出了一个框架F*来正式验证Solidity编写的智能合约，它忽视了一些结构，比如说循环。考虑到我们分析的22493个合约，将近93%的智能合约包含循环。所以他们的工具只能在一小部分的公开合约上使用，他们的结果对这一点也进行了论证，在396个合约中他们只能分析其中46个。但是使用F*可以推理大多数正确性和公平性的属性，它的作者建议对这种推理使用手工证明，虽然还不清楚这种情况什么时候会发生。相比之下，我们建立了一个大规模的自动验证。Why3是一个正式验证Solidity合约可靠性的实验工具，它正处于开发中并且仅支持少部分的语法。更进一步，Solidity到Why3的翻译没有经过测试也不可信。我们提出了ZEUS的设计和实现—使用抽象解释和符号执行来自动化正式验证智能合约的实践框架。ZEUS使用高级语言编写的智能合约作为输入，它利用用户帮助来生成一个XACML模板风格的正确性和公平性的标准。它将这些合约和特定的准则翻译成一个低级的中间表示，比如说LLVM字节码，对执行语义进行编码以正确推断合约行为。然后在中间代码上进行静态分析以确定必须声明验证的谓词。最后ZEUS将修改后的IR放入验证引擎中，验证引擎使用CHCs来快速验证智能合约的安全性。ZEUS利用三个主要的观察指标来保证稳定性和可靠性。第一，虽然区块链的执行类似于基于任务语义的并发系统，一个交易只能从一个智能合约公开函数调用开始。这种属性大大减少了验证大多数属性的状态空间探索。而且，交易之间的数据依赖比如说在持续变量之间的读写依赖要求分析O(n^2)对事务交错。第二，智能合约是控制流和数据流驱使的，所以使用抽象解释和符号模型对智能合约建模允许ZEUS可靠的推测程序行为。抽象解释计算数据域上的循环和函数摘要，然后在模型检查阶段使用这些循环和函数摘要，减少模型检查阶段操作的状态空间。最后，CHCs提供一个合适的机制来表示验证条件，它可以被SMT求解器有效地释放。SMT solver(Satisfiability modulo theories)可满足模理论求解器 SAT—布尔可满足性求解器。用于求解等式系统，不同的是，SMT接受不同格式的等式系统，而SAT对输入格式是有要求的，必须是CNF范式的布尔等式。用于形式化验证 XACML(eXtensible Access Control Markup Language可扩展访问控制标记语言) 是一个定义用于访问控制的体系结构和语言，语言由响应、回复和Policy组成，客户端发送一个请求给服务器，询问一个特定的动作是否可以被允许执行。服务器使用已有的Policy对请求进行评估，然后进行回复。这些Policy实现了组织的访问控制请求。 ZEUS基于LLVM字节码做验证也收益良多，不仅仅是因为ZEUS可以使用一个产业化的工具链做分析，它还允许ZEUS在标准化的LLVM字节码上插入任意验证器，使用LLVM字节码还帮助ZEUS验证不同区块链平台的智能合约，包含以太坊、超级账本，使用不同高级语言编写，比如说C#,Go和JAVA。注意，大多数高级语言到LLVM字节码的翻译器已经可以获得。我们使用LLVM丰富的API集合来编写第一个Solidity到LLVM字节码的翻译器，为了验证忠实地实现了大多数Solidity语法的执行语义。更进一步，使用LLVM允许ZEUS将翻译实现和验证分离。这篇文章做出来以下贡献：(1) 我们对新的或者早已出现但是没有经过研究的事件在智能合约的上下文中进行分类，并且证明他们可以潜在地导致资金流失。(2) 我们提出了一种形式化的Solidity执行语义抽象，结合抽象解释和符号模型检查来验证智能合约。(3) 我们设计并实现了ZEUS，一个符号模型检查框架来验证正确性和合法性，我们设计了第一个Solidity到LLVM字节码的翻译器，并且提供一个程序分析模型来自动化插入给定Policy规范的验证条件。我们还提供了抽象Policy来正确建模Solidity的执行语义保证可靠性。更近一步，我们建立了一个交互式谓词提取工具便于智能合约中多方交互。(4) 我们进行了第一个大规模Solidity智能合约源码分析，我们分析了22493个智能合约(1524个比较特殊)表明大概有94.6%的合约有一个甚至多个安全漏洞。但是我们并没有研究这些漏洞的实际可利用性。而且我们选择了几个有代表性的合约并且应用了一些智能合约特定的公平性准则。(5) 智能合约有零漏报率，并且在我们的数据集上优于Oyente，误报率低，在分析时间上有一个数量级的改进。(6) 通过用它分析超级账本的智能合约，我们展示了ZEUS的普遍可用性。我们还通过使用SMACK进行验证，演示了将ZEUS应用于选择的验证器的易用性(SMACK用于将源语言细节与验证器实现解耦) 背景区块链是进行多方可验证交易的分布式账本，可以防止篡改和抵赖。除了交易之外，每一个区块还包含状态元数据(创建时的时间戳、交易的Merkle哈希、上一个块的哈希值、智能合约代码和数据)，挖矿是对每个块执行分布式计算评审的过程，用于相互不信任的环境中实现共识无限制区块链：公有链有限制区块链：联盟链 激励智能合约的正确性和安全性问题 A. 正确性问题(1) 重入攻击是因为call语句导致合约控制流转换产生的漏洞12345678910111213contract Wallet&#123; mapping(address =&gt; uint) private userBalances; function withdrawBalance() &#123; uint amountToWithdraw = userBalances[msg.sender]; if (amountToWithdraw &gt; 0) &#123; msg.sender.call(userBalances[msg.sender]); userBalances[msg.sender] = 0; &#125; &#125; ...&#125; 12345678contract AttackerContract&#123; function () &#123; Wallet wallet; wallet.withdrawBalance(); &#125;&#125; (2) 未经检查的sendsend操作如果失败合约并不终止，而是返回false，有些合约不检查send执行的状态直接进行下一步操作导致合约出现漏洞。12345if(gameHasEnded &amp;&amp; !prizePaidOut)&#123; winner.send(1000); // send a prize to the winner prizePaidOut = True;&#125; (3) send操作失败(4) 整数上下溢出(5) 交易状态依赖tx.origin指的是交易的最初发起者，但交易的最初发起者不一定是智能合约函数的直接调用者。1234567contract UserWallet &#123; function transfer(address dest, uint amount) &#123; if (tx.origin != owner) &#123; throw; &#125; dest.send(amount); &#125;&#125; 1234567contract AttackWallet &#123; function() &#123; UserWallet w = UserWallet(userWalletAddr); w.transfer(thiefStorageAddr, msg.sender.balance); &#125;&#125; 可以使用社会工程学的方式诱导UserWallet的部署者调用AttackWallet合约，此时tx.origin指的就是UserWallet而不是msg.sender B. 公平性的问题语义正确的合约并不一定遵守实际逻辑(1) 逻辑抽象使用selfdestruct时不对调用者的身份进行检测。解决问题会给予奖励，但是如果合约中的金额不足以支持奖励支付可能会导致合约得到了难题的解答但是并没有给予解决问题的人奖励。(2) 逻辑不正确相似的变量名或者函数名导致的混淆构造函数与合约名称完全不同并且为public类型，导致外部也可以调用这个构造函数(3) 逻辑正确但是不公平指的是合约代码不符合实际的商业逻辑需求。论文中举的是一个进行拍卖的合约，正常拍卖活动中应该限制拍卖方进行竞价，合约中并没有排除这种拍卖方竞价的情况。 C. 矿工的影响(1) 区块状态依赖。时间戳、挖矿难度、gaslimit这些变量可能被用来生成随机数，但是这些变量可以被区块头部影响，而矿工又可以影响区块头部内容(加大成功的概率)(2) 交易顺序依赖。矿工可以决定一个区块中的交易顺序。并发系统长期以来都在处理由于事务排序而导致的数据竞争问题。虽然Solidity不支持并发性，但由于其自身的重新排序标准，矿工可以影响事务的结果。由于这种对事务排序的依赖是一个通用的区块链特性，所以我们认为它是一个限制，而不是缺陷。 ZEUSZEUS的组成：1.policy构建器;2.源代码翻译器;3.验证器。ZEUS使用智能合约源码和使用特定语言编写的policy(用来验证合约)作为输入，它在智能合约的代码之上执行静态分析，并将Policy谓词作为assert语句插入正确的程序点。ZEUS使用翻译器将带有Policy assert语句的智能合约翻译成LLVM字节码。最后ZEUS调用它的验证器来确定assert违规，这表示Policy违规(就是调用验证器来确定assert语句是否会执行，如果执行了就表示违规) A. 标准化Solidity语法设计了一个抽象语言来捕获Solidity程序的相关结构。一个程序由一系列的合约声明组成。除了声明和初始化合约的持久私有存储之外，每个合约可以抽象地看作一个或多个方法定义的序列，这些方法定义由关键字global表示。一个合约可以用一个ID唯一的表示，ID属于一组标识符。调用一个合约的public函数可以看成一笔交易。为了简化，方法只有一个输入变量类型T和一个单一的全局变量，所以T可以是集合或者结构体。Solidity中的函数调用可以分为三种:internal, external和call。internal和external是通过goto语句实现的或者是内联的。call调用使用post。合约的主体被标记位S。相反，可以使用跨合约的参数调用post语句。因此，参数l是post的一部分。我们语言的语义抽象具体的值和操作。因此，对我们来说，T或特定表达式语言e的枚举仍然是未指定的。语言的具体细节不重要，我们可以假定为任何传统命令式语言定义的线性算术表达式。havoc语句为变量l赋一个不确定的值。assert语句在符号编码中引入了对谓词真值的检查。assume语句阻塞，直到提供的表达式变为true并在合约中的给定控件位置指定数据状态为止。虽然关于Solidity和我们的抽象语言在语义上的等价性的正式讨论是可取的，并且可以通过定义从Solidity结构到抽象语言结构的抽象函数来建立，但是为了空间的利益，我们省略了它。相反，我们用抽象语言直观地推理各种Solidity结构及其等效模型。class,library和interfaces这些结构在我们的抽象语言中可以被认为是全局变量和函数的集合，编译器在翻译C/C++代码到LLVM字节码的过程中也将他们视作相似的。struct,mapping,array,bytes都是全局的。像sha256这种可以影响同一个合约状态的方法被认为是external方法。像send,transfer和call这种对地址进行操作的语句是通过post语句进行建模的。像selfdestruct这样的特殊结构是用我们的抽象语言本地建模的。Solidity中所有的控制语句和函数修饰符都可以被解糖成if-then-else和goto的形式。像assert,require和throw这种出错处理也可以用if-then和throw表示。注意，在我们的语言中assert和assume是用来做验证的，assert语句与在Solidity中的语法不同。其他的编译指令，比如说constant和storage也被解糖了，而不是用我们的抽象语言明确建模的。语法糖语法糖实际上是一种便捷写法。比如说input.map(item =&gt; item + 1)表示的是：123input.map(function (item) &#123; return item + 1;&#125;); 语法糖的作用就是让写代码更加简单和容易理解。(相反的操作就是加盐)之所以叫「语法」糖，不只是因为加糖后的代码功能与加糖前保持一致，更重要的是，糖在不改变其所在位置的语法结构的前提下，实现了运行时等价。可以简单理解为，加糖后的代码编译后跟加糖前一模一样。语言语义区块状态被定义为：$&lt;&lt;\Gamma, \sigma&gt;, BC&gt;$, $&lt;\Gamma, \sigma&gt;$是B正在挖掘的块，BC是已经提交的块列表，$\Gamma$指已经完成但是还没有提交的交易集合。Val是表达式在求值后可以取的值集合。$\sigma$是全局状态，$\sigma:Id-&gt;g$指合约标识到全局变量的映射。$\sigma$是指矿工按照特定顺序执行$\Gamma$后的状态。最后，交易确定后矿工将B加入自己的区块中。交易由一系列的帧(用$\gamma$表示)组成。每一个帧被进一步定义为$f := &lt;l, id, M, pc, v&gt;$,l是方法的局部变量，M是合约(标识符为id)的代码，pc是程序计数器，v := 是用来存储输入输出的辅助存储器。$\gamma$的顶帧是正在执行的帧，与目前正在进行的交易有关，它不是持久区块链状态的一部分。一个空的帧可以被标记为$\epsilon$，标识符c被定义为$c := &lt;\gamma, \sigma&gt;$用来捕获交易状态，$\leadsto$表示小步骤操作语义.下表列出了管理配置更改的相关语法规则，其余顺序语句的规则是标准的。符号$\to$说明一个交易与全局状态和区块链状态相关。符号$\gets$表示对一个lvar(局部变量)赋值。Table 1 B.标准化规则语言假设PVars是一组程序变量，Func是一组智能合约中的函数名称，Expr是一组条件表达式(特定的无量词一阶逻辑(FOL)公式)。Policy规范必须使用这些语法符号，以避免在验证期间产生歧义ZEUS利用用户的帮助建立了一个XACML风格的Policy模板&lt;Sub, Obj, Op, Cond, Res&gt;。$Sub \in PVar$ 是一组需要被跟踪的变量，$Obj \in PVar$是一组与主体交互的变量，Op是一组侧影响调用，用于捕获主体和对象之间交互的效果。Op还指定了一个触发器属性，即“pre”或“post”，指示谓词应该在指定操作之前还是之后保存，换句话说，Op := &lt;f, trig&gt;这里$f \in Func, trig \in (pre, post)$。条件$Cond \in Expr$是一组控制导致交互操作的谓词集。最后,$Res \in {T, F}$表明主体和操作之间被谓词控制的交互是被允许的还是被禁止的.Policy到assertion之间的转换我们的抽象语言包含assertion来定义智能合约中的状态可达特性。ZEUS利用policy来提取(a)需要assert的谓词(i.e. Cond)(b)在程序源代码中插入assert语句的正确控制位置.Cond在我们的抽象语言中是一个表达式，使用这个表达式谓词并将其包装在assert(exp)下，将在我们的抽象语言中创建一条语句，Res指示条件是以正常形式出现，还是以否定形式出现在assert语句中.Op表示谓词(如条件所示)必须满足trig.trig和Sub,Obj准确地判断操作的哪些调用应该以条件为前缀或后缀。换句话说，我们精确地知道了抽象程序P中必须assert Cond的位置更正式的说，$f: Sub \times Obj \times Op \to Loc$，Loc是一组程序位置。使用污点分析来确定Sub和Obj结合使用的地方，通过只选择调用指定操作的那些控件位置，可以进一步细化此集合。最后的位置就是需要assert(Cond)的位置。 C.可靠性将源代码翻译成带有assert语句的抽象语言，并最后转换成LLVM字节码的过程是可靠的。1.Solidity翻译成我们的抽象语言不会影响语法表现，2.保守的替换assert语句不会影响方法的可靠性，2.把policy的确认问题转换成了一个状态可达问题。4.在Solidity程序的上下文中定义了一个可达状态。5.我们证明，通过确保程序的过近似版本具有状态可达性，我们不会遗漏任何程序行为。最后，我们证明从过近似的Solidity程序到LLVM字节码的翻译是完全一对一的翻译，我们的整体稳健性模块的决策过程被保留。(1) 从Solidity到抽象语言从Solidity到我们抽象语言的翻译过程保留了源语言的语义行为，虽然我们需要一个关于实体的语义等价性和我们的抽象语言的形式化论证，但是为了空间的利益，我们忽略了它。(2) 污点分析对可靠性的影响污点分析确定插入谓词语句的位置，可能会在多个位置插入谓词语句，这种插入可能会引入误报率但是不会漏报，所以我们的方法是可靠的。(3) policy验证的语义实现policy是无量词的一阶逻辑公式，policy的验证可以被简化成状态可达问题，i.e.是否存在从开始策略就不成立的可达状态。policy $\phi$ hold on 程序P,当$N \models \phi$,N是程序P做一个状态转换关系有限自动机的正式表示。assert(exp)在抽象语言中与高级语言中的assert语句有不同的语法含义。(4) 程序中assertion的安全意味着policy的确认定理1:源程序的安全性等价于翻译后程序的安全性证明:assert语句的语义规则表明不会对除了程序计算器以外的任何数据状态造成改变。assert仅作为标记与底层验证器相关，以生成验证条件。翻译前后的程序行为相同，所以assertion的安全性也相同。(5) Over-approximation的安全性assert语句的加入不影响安全性(6) 方法的安全性抽象语言到LLVM字节码也是安全的(soundness) D.通过CHCs执行符号检查ZEUS使用CHCsA. Gurfinkel et al., “The SeaHorn Verification Framework,” in CAV’15来验证翻译成LLVM字节码后程序的安全性.CHC表示的优点使其能够与各种基于smt的求解器和现成的模型检查器进行交互 E.端到端的示例下图展示了一个各种端到端翻译的示例，合约向msg.sender发送msg.value的金额，然后在bal[msg.sender]中减去msg.value。policy检查send调用必须满足msg.sender的余额大于msg.value。ZEUS从policy中提取条件，将其转换成assert语句放入Solidity中，然后将其转换成抽象语言，最后将程序翻译成LLVM字节码。 实现在Solidty的C++编译器solc的基础上实现policy builder和Solidity到LLVM的翻译器。使用Seahorn做符号模型检查的后端来验证policy。我们没有从头构建验证器，而是确定在LLVM字节码上使用CHCs时Seahorn为我们提供了一个现成的使用生成验证条件的实现。但是ZEUS不与Seahorn耦合，还可以使用任何工作在LLVM字节码上的验证器，比如说SMACK和DIVINE. A. Policy BuilderZEUS从AST节点上提取标识信息。从AST树的函数调用节点上提取操作，而谓词是从表示二进制操作的节点中的条件中提取的。ZEUS在合约代码上进行污点分析，然后进行API提取，ZEUS还会捕获控制流条件和路径谓词，污点分析的输出是一组元组，由源、对象、接收器及其对应的路径谓词组成。然后ZEUS列出了所有可用的污点集合，即，全局变量和环境变量，用户从中选择要跟踪的subject。然后，它过滤来自污点分析的结果，该污点分析将搜索空间减少到包含用户选择的至少一个subject的元组.ZEUS然后提示用户选择对象，然后进一步删除元组列表.然后显示至少涉及一个或多个subject或object的潜在调用的列表。在进一步选择之后，ZEUS列出了从源到接收器所遇到的可用谓词。用户可以使用布尔运算符组合这些谓词(或指定自己的谓词)，以在策略中形成条件，并指示是否将它们作为前置条件或后置条件检查。最后，用户在结果标记中指出规范是否确定了违反或接受的行为。 B. Solidity到LLVM字节码的翻译器为了便于实现，它读取策略规范并重写位代码(而不是Solidity源代码)，以便按照规范中的触发器属性为谓词注入断言条件。大多数Solidity的语句和表达式都有与C/C++相同的语义。使用LLVM的API来翻译AST。(1) 执行顺序由于在没有强制执行全局调用顺序的情况下，可以任意地对契约的公共函数进行许多并行调用，因此建模这些无限多的执行顺序是不可能的。我们注意到，对于7个类中的6个类(除了依赖于事务顺序的类)，错误检测是事务内部的。换句话说，验证者需要对一个调用链中的bug进行推理。事务的顺序不会影响事务中的bug检测。对事务顺序依赖关系的检测涉及到跨一对事务检测对敏感全局变量的写操作和后续读操作。对函数对进行推理就足够了，因为事务顺序依赖的最小实例必须在至少两个函数调用之间表现出来。剩余函数的排序对于检测bug来说是无关紧要的。因此，对于具有n个公开可用函数的契约，ZEUS必须对O(n^2)可能的排序进行推理。ZEUS产生了一套main函数，作为验证的切入点。具体来说，主函数是一个在调用公开定义的函数之前拥有所有全局状态的工具。对于事务顺序依赖，ZEUS拥有全局状态，并从一个主要功能中调用所有公共功能的成对排列。此外，ZEUS在调用call家族的任何成员时拥有整个全局状态。(2) 路径遍历在Solidity中，全局变量在执行过程中保持状态。在一个静态分析执行中建模和推理所有这些状态是不切实际的。因此，ZEUS将契约中所有全局变量(包括块和事务状态变量)的值抽象为与数据类型对应的整个数据域。例如，uint256类型的全局变量被建模为具有整型域，并且可以接受0到INT_MAX之间的任何值。对于任何具体定义的起始值，ZEUS都会自动使用它们来探索整个数据域。保持初始值不变并不会导致所有可能的执行，因为该值可能在后续的契约执行中增加，并可能在将来导致潜在的可使用性。因此，单个静态执行就足以分析所有可能的控制路径。==blabla翻译高级语法的一些细节和ZEUS的缺陷== C.Handling Correctness Bugs(1)重入漏洞创建一个完全相同的函数，但是其中加入assert(false)语句，主要是为了验证在进行实际的转账操作之前是否对变量进行了操作。(2)send状态没有检查禁止在send操作失败的时候对全局变量进行修改。即在每一个全局变量修改的地方插入assert()语句。(3)send失败不允许在send失败的时候立刻调用throw语句。(4)整数溢出操作使用LLVM工具链中的整数检查器。]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文,智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下LLVM开发环境的配置]]></title>
    <url>%2F2018%2F10%2F08%2Fllvm%2F</url>
    <content type="text"><![CDATA[安装clang和cmakesudo apt-get install clang cmake 安装llvmsudo apt-get install llvm使用这种方法我默认安装上的llvm版本为3.8.0，安装后的文件目录为/usr/share/llvm-3.8 修改LLVMConfig.cmake文件set(LLVM_CMAKE_DIR &quot;${LLVM_INSTALL_PREFIX}/share/llvm/cmake&quot;)改为set(LLVM_CMAKE_DIR &quot;${LLVM_INSTALL_PREFIX}/share/llvm-3.8/cmake&quot;) 修改LLVMExports-relwithdebinfo.cmake文件由于权限问题不能直接打开修改，在命令行中写入:sudo gedit LLVMExports-relwithdebinfo.cmake对文件进行如下修改:123#Commands may need to know the format version. set(CMAKE_IMPORT_FILE_VERSION 1)set(_IMPORT_PREFIX &quot;/usr/lib/llvm-3.8&quot;) 注释与Polly相关的库引用1234567891011121314151617181920212223242526272829# Import target "PollyISL" for configuration "RelWithDebInfo" # set_property(TARGET PollyISL APPEND PROPERTY IMPORTED_CONFIGURATIONS RELWITHDEBINFO) # set_target_properties(PollyISL PROPERTIES # IMPORTED_LINK_INTERFACE_LANGUAGES_RELWITHDEBINFO "C" # IMPORTED_LOCATION_RELWITHDEBINFO "$&#123;_IMPORT_PREFIX&#125;/lib/libPollyISL.a" # ) # # list(APPEND _IMPORT_CHECK_TARGETS PollyISL ) # list(APPEND _IMPORT_CHECK_FILES_FOR_PollyISL "$&#123;_IMPORT_PREFIX&#125;/lib/libPollyISL.a" ) # # # Import target "Polly" for configuration "RelWithDebInfo" # set_property(TARGET Polly APPEND PROPERTY IMPORTED_CONFIGURATIONS RELWITHDEBINFO) # set_target_properties(Polly PROPERTIES # IMPORTED_LINK_INTERFACE_LANGUAGES_RELWITHDEBINFO "CXX" # IMPORTED_LOCATION_RELWITHDEBINFO "$&#123;_IMPORT_PREFIX&#125;/lib/libPolly.a" # ) # # list(APPEND _IMPORT_CHECK_TARGETS Polly ) # list(APPEND _IMPORT_CHECK_FILES_FOR_Polly "$&#123;_IMPORT_PREFIX&#125;/lib/libPolly.a" ) # # # Import target "LLVMPolly" for configuration "RelWithDebInfo" # set_property(TARGET LLVMPolly APPEND PROPERTY IMPORTED_CONFIGURATIONS RELWITHDEBINFO) # set_target_properties(LLVMPolly PROPERTIES # IMPORTED_LOCATION_RELWITHDEBINFO "$&#123;_IMPORT_PREFIX&#125;/lib/LLVMPolly.so" # IMPORTED_NO_SONAME_RELWITHDEBINFO "TRUE" # ) # # list(APPEND _IMPORT_CHECK_TARGETS LLVMPolly ) # list(APPEND _IMPORT_CHECK_FILES_FOR_LLVMPolly "$&#123;_IMPORT_PREFIX&#125;/lib/LLVMPolly.so" ) 使用LLVM进行开发新建文件夹: HowToUseJIT目录结构如下:12345HowToUseJIT -- src + -- HowToUseJIT.cpp -- CMakeLists.txt -- build 在HowToUseJIT文件夹下进行如下操作:123cd buildcmake ..make HowToUseJIT.cpp和CMakeLists.txt文件可以自己根据LLVM提供的API自行开发，也可以使用下面所给的例子：HowToUseJIT.cpp1234567891011121314151617181920212223242526272829303132333435363738#include "llvm/IR/LLVMContext.h"#include "llvm/IR/Function.h"#include "llvm/IR/BasicBlock.h"#include "llvm/ADT/ArrayRef.h"#include "llvm/IR/Module.h"#include "llvm/IR/IRBuilder.h"#include &lt;vector&gt;#include &lt;string&gt; int main()&#123; llvm::LLVMContext &amp; context = llvm::getGlobalContext(); llvm::Module *module = new llvm::Module("asdf", context); llvm::IRBuilder&lt;&gt; builder(context); llvm::FunctionType *funcType = llvm::FunctionType::get(builder.getVoidTy(), false); llvm::Function *mainFunc = llvm::Function::Create(funcType, llvm::Function::ExternalLinkage, "main", module); llvm::BasicBlock *entry = llvm::BasicBlock::Create(context, "entrypoint", mainFunc); builder.SetInsertPoint(entry); llvm::Value *helloWorld = builder.CreateGlobalStringPtr("hello world!\n"); std::vector&lt;llvm::Type *&gt; putsArgs; putsArgs.push_back(builder.getInt8Ty()-&gt;getPointerTo()); llvm::ArrayRef&lt;llvm::Type*&gt; argsRef(putsArgs); llvm::FunctionType *putsType = llvm::FunctionType::get(builder.getInt32Ty(), argsRef, false); //llvm::Constant *putsFunc = module-&gt;getOrInsertFunction("puts", putsType); llvm::Function *putsFunc = llvm::Function::Create(putsType, llvm::Function::ExternalLinkage, "puts", module); llvm::BasicBlock *putsentry = llvm::BasicBlock::Create(context, "entrypoint", putsFunc); builder.SetInsertPoint(putsentry); builder.CreateCall(putsFunc, helloWorld); builder.CreateRetVoid(); module-&gt;dump();&#125; CMakeLists.txt123456789101112131415161718192021222324252627282930313233343536373839404142cmake_minimum_required(VERSION 2.8)project(llvm_test)set(LLVM_TARGETS_TO_BUILD X86)set(LLVM_BUILD_RUNTIME OFF)set(LLVM_BUILD_TOOLS OFF)find_package(LLVM REQUIRED CONFIG)message(STATUS "Found LLVM $&#123;LLVM_INCLUDE_DIRS&#125;")message(STATUS "Using LLVMConfig.cmake in: $&#123;LLVM_DIR&#125;")SET (CMAKE_CXX_COMPILER_ENV_VAR "clang++")SET (CMAKE_CXX_FLAGS "-std=c++11")SET (CMAKE_CXX_FLAGS_DEBUG "-g")SET (CMAKE_CXX_FLAGS_MINSIZEREL "-Os -DNDEBUG")SET (CMAKE_CXX_FLAGS_RELEASE "-O4 -DNDEBUG")SET (CMAKE_CXX_FLAGS_RELWITHDEBINFO "-O2 -g")SET(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)add_definitions($&#123;LLVM_DEFINITIONS&#125;)file(GLOB_RECURSE source_files "$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp")add_executable(llvm_test $&#123;source_files&#125;)install(TARGETS llvm_test RUNTIME DESTINATION bin)# Find the libraries that correspond to the LLVM components# that we wish to usellvm_map_components_to_libnames(llvm_libs Core ExecutionEngine Interpreter MC Support nativecodegen)# Link against LLVM librariestarget_link_libraries(llvm_test $&#123;llvm_libs&#125;) 如果编译通过说明LLVM开发环境搭建成功，如果报一些库文件缺失的错误有可能是因为默认LLVM文件夹的文件名为llvm而安装LLVM后自带的文件名为llvm-3.8可以根据报错内容对/usr/share/llvm-3.8或usr/lib/llvm-3.8的文件名进行修改]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
      </tags>
  </entry>
</search>
